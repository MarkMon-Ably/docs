A @PaginatedResult@ is a type that represents a page of results for all message and presence history, stats and REST presence requests. The response from a "paginated REST API query":/rest-api/#pagination is accompanied by metadata that indicates the relative queries available to the @PaginatedResult@ object.

h4.
  default: Properties
  java:    Members
  ruby:    Attributes

- @items@ := contains a page of results (for example an Array of "@Message@":#message or "@PresenceMessage@":#presence-message objects for a channel history request)<br>__Type: Array <Message, Presence, Stats>__

- <div lang="default">@isLast@</div> := @true@ if this page is the last page<br>__Type: Boolean__
- <div lang="ruby">@last?@</div> := @true@ if this page is the last page<br>__Type: Boolean__

- <div lang="default">@hasNext@</div> := @true@ if there are further pages<br>__Type: Boolean__
- <div lang="ruby">@has_next?@</div> := @true@ if there are further pages<br>__Type: Boolean__

h4. Methods

h6. first

bq(definition).
  default:  first(callback("ErrorInfo":/realtime/types#error-info err, "PaginatedResult":/realtime/types#paginated-result resultPage))
  ruby:     "PaginatedResult":/realtime/types#paginated-result first
  java:     public "PaginatedResult":/realtime/types#paginated-result first()

Returns a new @PaginatedResult@ for the first page of results. <span lang="ruby">When using the Realtime library, the @first@ method returns a "Deferrable":/realtime/types#deferrable and yields a "PaginatedResult":/realtime/types#paginated-result.

h6. items

bq(definition).
  default:  Object[] items()
  ruby:     Object[] items
  java:     public Object[] items()

Returns the current page of results as an Array. The type of the objects in the Array is determined by the operation that provided the @PaginatedResult@. For example, a "Message#history":/realtime/channels-messages#history request will return an array of @Message@ objects.

h6. next

bq(definition).
  default:  next(callback("ErrorInfo":/realtime/types#error-info err, "PaginatedResult":/realtime/types#paginated-result resultPage))
  ruby:     "PaginatedResult":/realtime/types#paginated-result next
  java:     public "PaginatedResult":/realtime/types#paginated-result next()

Returns a new @PaginatedResult@ loaded with the next page of results. If there are no further pages, then <span lang="default">@null@</span><span lang="java">@Null@</span><span lang="ruby">@nil@</span> is returned. <span lang="ruby">When using the Realtime library, the @first@ method returns a "Deferrable":/realtime/types#deferrable and yields a "PaginatedResult":/realtime/types#paginated-result.

h4. Example

```[jsall]
channel.history(function(err, paginatedResult) {
  console.log('Page 0 item 0:' + paginatedResult.items[0].data);
  paginatedResult.next(function(err, nextPage) {
    console.log('Page 1 item 1: ' + nextPage.items[1].data);
    console.log('Last page?: ' + nextPage.isLast;
  });
});
```
```[java]
PaginatedResult firstPage = channel.history();
System.out.println("Page 0 item 0:" + firstPage.items[0].data);
if (firstPage.hasNext) {
  PaginatedResult nextPage = firstPage.next();
  System.out.println("Page 1 item 1:" + nextPage.items[1].data);
  System.out.println("More pages?:" + Strong.valueOf(nextpage.hasNext()));
});
```
```[ruby]
# When using the REST sync library
first_page = channel.history
puts "Page 0 item 0: #{first_page.items[0].data}"
if first_page.has_next?
  next_page = first_page.next
  puts "Page 1 item 1: #{next_page.items[1].data}"
  puts "Last page?: #{next_page.is_last?}"
end

# When using the Realtime EventMachine library
channel.history do |first_page|
  puts "Page 0 item 0: #{first_page.items[0].data}"
  if first_page.has_next?
    first_page.next do |next_page|
      puts "Page 1 item 1: #{next_page.items[1].data}"
      puts "Last page?: #{next_page.is_last?}"
    end
  end
end
```
