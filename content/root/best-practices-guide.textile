---
title: Best Practices Guide
section: root
index: 30
jump_to:
  Contents:
    - Ably 101
    - Using Ably like a pro
---

h2(#title). Ably Best Practices Guide

In order to avail the best advantage of our platform, be sure to follow this best practices guide while building your applications using Ably.

h3(#ably-101). Ably 101

Ably Realtime is a cloud-based platform that allows you to easily integrate realtime functionality into your applications. Just plug and play.

h4(#pubsub). Publish and Subscribe

Publish data to a named "channel":/realtime/channels-messages on the Ably Realtime platform, and everyone subscribed to that same channel will receive it.

h4(#notifications). Notify

You can use "Push Notifications":/realtime/push to inform your users about the cool new features you are building in your application.

h4(#presence). Be present

Go online and let others in your application know this by using "Presence":/realtime/presence. You can also see who else is present on a channel even when you yourself are NOT present.

h4(#rest-or-realtime). Remain connected, or not

With the availability of both the "Realtime":/realtime and "REST":/rest libraries, choose what suits your application's needs best and get started.

h4(#auth). Choose the right auth scheme

Use "Basic Authentication":/general/authentication#basic-authentication or "Token Authentication":/general/authentication#token-authentication as well as ensure security by "encrypting your messages.":/realtime/encryption

h3(#using-ably-like-a-pro). Using Ably like a pro

h4. 1. Use separate channels when you want messages to be sent to different sets of subscribers.

* Ably pushes all the data published on a channel to every subscriber attached to that channel. Subscribers can choose to only subscribe to events with a certain message name, but that filtering is done on the client side (however, it's useful for things like letting the subscriber trigger different listeners for different events). If you have messages that don't need to be sent to some clients at all, you're often better off using a separate channel for those instead of implementing a filter. This way, you won't be sending unnecessary messages that count towards your package limit.

h4. 2. Handling connection and channel state&#45;change events

* Ably's Realtime SDKs automatically handle disruptions such as network disconnections, so you don't need to do anything. The library emits "connection":/realtime/connection#connection-states and "channel":/realtime/channels-messages#channel-stateschannel state change events that you can listen to in case you'd like be informed about what it's doing (for example, if you want to know whenever the library has lost message continuity on a channel due to being disconnected for more than two minutes). But there's no need to take any particular action in response to any of these, the library will automatically reconnect and reattach to channels after the network disruption is over.

h4. 3. Using API key on the client side

* Ably's "Basic Authentication":/general/authentication#basic-authentication method is the easiest way to authenticate your client on the Ably Realtime platform. However, it directly exposes the API key in the source code. When you use it on the client side, any entity that interacts with the client could view your API key and potentially misuse it. If you can run an auth server, we recommend using "Token Authentication":/general/authentication#token-authentication on the client side. "Read more":/general/authentication#selecting-auth about selecting an authentication mechanism.

h4. 4. Ensuring tokens are auto&#45;renewable

* Tokens are short lived and need to be constantly renewed. Rather than getting a token from your auth servers yourself and initializing the Client Library SDK with it, we recommend you instead initialize the SDK with an authUrl or authCallback. It will use this information to automatically request a token from your auth server's endpoint whenever it needs a new one, thus seamlessly switching to the new token without disconnecting, hence ensuring an uninterrupted service.

h4. 5. Choosing between Realtime/ REST libraries and Protocol Adapters 

* Want to maintain a persistent connection with Ably's Realtime platform, so you can subscribe to messages sent on a channel, or be notified whenever the presence set changes? Use the "realtime library":/realtime.
* Want to just publish data to the platform, don't care about subscribing, and don't want to manage channel attachment? Use the "REST library":/rest.
* Want to publish at very high volumes or with the lowest possible latency? "The realtime libary can publish at higher volumes (due to message pipelining) and lower latencies than is possible with the REST library":https://support.ably.io/solution/articles/3000060319-should-i-use-the-rest-or-realtime-library.
* Want to get one&#45;time info about the presence set of a channel? Use the "REST library":/rest.
* Want to set up realtime communication with IoT devices on platforms for which there's no native Ably client library available? Use the "MQTT protocol adapter":/mqtt.
* Want to migrate from PubNub/Pusher? Use the relevant "protocol adapter":/adapters to "ease the pain of migration":https://support.ably.io/solution/articles/3000054127-can-you-help-ease-the-pain-of-migration-from-another-realtime-service: you can switch to Ably right away while sticking with your current client libraries, and gradually migrate to native Ably clients.

h4. 6. Subscribing to events on the server&#45;side

* Subscribing to events on the server side using the standard Pub/Sub pattern can be a bad idea for a number of reasons as explained in this "blog article":https://blog.ably.io/message-queues-the-right-way-to-process-and-work-with-realtime-data-on-your-servers-2d15985301f8. With Message Queues, you can set up multiple worker servers to distribute the load of the messages received from Ably while ensuring each of the messages gets processed exactly once by any one of your worker servers.

h4. 7. WebHooks/Reactor Functions vs. Message Queues &#45; when to use what?

* "WebHooks":/general/webhooks and "Reactor Functions":/general/functions work well for low or medium message volumes, but "Reactor Queues":/general/queues will scale better to high message volumes. For very high volumes, we recommend using "Reactor Firehose":/general/firehose.

h4. 8. Multiplexing channels

* You should almost always instantiate a single Ably client library instance per web page or server. Don't forget that the Client Library SDK can "multiplex":https://support.ably.io/support/solutions/articles/3000058406-do-you-support-channel-groups-and-multiplexing many channels over a single connection.

h4. 9. Limiting the effect of a security compromise using the principle of least privilege

* Using the available "authentication methods":/general/authentication in Ably, you can choose the permissions or capabilities to be given to a client. You can do this by restricting the permissions on the API key as well as restricting the permissions your auth server grants to that API key whilst granting a token request. You can restrict the channels that a client can access (including with wildcards), as well as the operations the client can perform within those channels, using "capabilities":/general/authentication#capabilities-explained.
* Always make sure to limit the capabilities given to a client to only what's required by the client to do their job. This prevents any unexpected behaviour by a client and increases the security of your application. This is called the principle of least privilege.

h4. 10. Efficient use of channels

Channels consume resources and hence cost you money. Make sure that you are using them efficiently and in accordance to the limit you have as per your package. However, bear in mind the following:

* Don't use different channels just to indicate different types of data or different events, if they're all going to the same set of clients. Use one channel, and distinguish between the different events using the message name.
* Channels are the unit of security and scalability. If you are sending some data that must not be shared with certain clients, make sure it's on a channel that those clients don't have the capabilities to attach to.
* Be aware that each channel can support a maximum of 100 messages per second.