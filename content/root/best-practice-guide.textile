---
title: Best Practice Guide
section: root
index: 30
jump_to:
  Contents:
    - Ably 101
    - Using Ably like a pro
---

h2(#title). Ably Best Practice Guide

This best practice guide aims to quickly get you to understand the best way to make use of Ably's Realtime platform for your applications. These recommendations include some important considerations that are otherwise prone to easy ignoration while skimming through the docs. 

This guide consists of the following two sections:
* Ably 101 - Key concepts that you must understand before moving on to the best practice recommendations.
* Using Ably like a pro - Actual recommendations that we've compiled as per our experience with our users, in order for you to avoid common mistakes or misunderstandings whilst using Ably.

h3(#ably-101). Ably 101

Ably Realtime is a cloud-based platform that allows you to easily integrate realtime functionality into your applications. Just plug and play.

h4(#pubsub). Publish and Subscribe (Pub/Sub)

You can publish data to a named "channel":/realtime/channels-messages on the Ably Realtime platform, and all the clients subscribed to that very channel will receive this data as it is being published.

h4(#notifications). Notifications 

You can use "Push Notifications":/realtime/push to send notifications to your clients even when they are currently not using your application, or in other words, not connected to Ably. You can do this both on mobile devices as well as browsers. You can also use "Smart Notifications":/general/smart-notifications for your notifications to be most effective depending on your user's connection statte, their active device or even their current context within your application.

h4(#presence). Presence

You can have your clients attach to the presence channel using "Presence":/realtime/presence in order to indicate if these clients (or devices in case of IoT clients) are online or connected. The changes in this connection status also can be tracked by optionally subscribing to the same presence channel.

h4(#rest-or-realtime). Realtime vs REST

With the availability of both the "Realtime":/realtime and "REST":/rest libraries, choose whichever suits your application's needs the best and get started. While using the realtime library lets your clients subscribe to certain data that Ably can push to your clients as it is being created, REST library offers simple stateless data publish or retrieval to and from Ably respectively.

h4(#auth). Choose the right auth scheme

You can use "Basic Authentication":/general/authentication#basic-authentication to easily authenticate your clients using an API key or use "Token Authentication":/general/authentication#token-authentication to authenticate your clients using a token request sent to Ably via your auth server. You can also "encrypt your messages":/realtime/encryption for added security of your application.

h3(#using-ably-like-a-pro). Using Ably like a pro

h4. 1. Attached channels automatically receive messages from Ably even without a subscribe listener

*Once a channel is attached, assuming the client has permission to subscribe to messages, the Ably platform will immediately start sending published messages to that client irrespective of whether there are any subscribe listeners registered on that client or not. A common misunderstanding is that only once a client "subscribes":/realtime/channels-messages#message-subscription to a channel will Ably start sending messages to the client. This is not the case as registering a listener with a Channel subscribe operation is a client-side operation only and is not communicated to Ably. 

h4. 2. Use separate channels when you want messages to be sent to different sets of subscribers

* Ably pushes all the data published on a channel to every subscriber attached to that channel. Subscribers can choose to only subscribe to events with a certain message name, but that filtering is done on the client side. If you have messages that don't need to be sent to some clients at all, you're often better off using a separate channel for those instead of implementing a filter. This way, you won't be sending unnecessary messages that count towards your package limit. However, in some cases where you wish to trigger different listeners for different events, setting up a single channel and filtering the messages client side would be more sensible. This is shown below:

```[javascript]
var sportsChannel = realtime.channels.get("sport");
//publish
sportsChannel.publish("update", { "team": "Man United" });
sportsChannel.publish("add", { "team": "Chelsea" });

//subscribe filters
sportsChannel.subscribe("update", function(){
  //do one thing
})
sportsChannel.subscribe("add", function(){
  //do another thing
})
```

h4. 3. Being present without subscribing to presence events

* If you want lots of people to be present, but not necessarily listen for "presence change events":/realtime/presence#presence-states, you should use token capabilities to prevent all users from receiving presence notifications while allowing them to enter only. This is a common scenario when you just want to know how many people are present on a channel at any point in time. An example of such a token capability is shown below:

```json
{
  "presenceChannel": ["publish", "presence"],
  "chat": ["presence", "history", "subscribe],
}
```

h4. 4. Handling connection and channel state-change events

Ably's Realtime SDKs automatically handle disruptions such as network disconnections, so you don't need to do manually handle reconnection. The library emits:

* "Connection":/realtime/connection#connection-states state change events such as @initialized@, @connecting@, etc. You can set up listeners for these state changes in order to handle connection failures such as those occuring due to failed authentication. An example of handling connection state-change event is shown below:

```javascript
realtime.connection.on(function(stateChange) {
  console.log('New connection state is ' + stateChange.current);
});
```

* "Channel":/realtime/channels-messages#channel-states state change events for various channel states such as @initialized@, @attaching@, etc. Similar to connection state changes, you can set up listeners for channel state changes as well, in case you'd like be informed about what's happening. For example, if you want to know whenever the library has lost message continuity on a channel due to being disconnected for more than two minutes. An example of handling channel state-change event is shown below:

```javascript
var myListener = function(stateChange) {
  console.log('channel state is ' + stateChange.current);
  console.log('previous state was ' + stateChange.previous);
});
channel.on(myListener);
```
However, while registering listeners for both connection and channel state change events, bear in mind that certain repeating states might add new listeners everytime. For instance, registering a listener @on(connected)@ adds a new listener every time the client becomes connected, even if this is a reconection after being offline for a while.

h4. 5. Using API key on the client side

* Ably's "Basic Authentication":/general/authentication#basic-authentication method is the easiest way to authenticate your client on the Ably Realtime platform. However, it directly exposes the API key in the source code. When you use it on the client side, any entity that interacts with the client could view your API key and potentially misuse it. If you can run an auth server, we recommend using "Token Authentication":/general/authentication#token-authentication on the client side. "Read more":/general/authentication#selecting-auth about selecting an authentication mechanism.

h4. 6. Ensuring tokens are auto-renewable

* It is almost never correct to provide a token to a client library without ensuring the client library has a means to get a new token automatically when it needs one (tokens expire as they are intentionally short lived). The Ably client library SDKs provide two mechanisms in the "ClientOptions":/realtime/authentication#token-authentication so that they can obtain tokens automatically, via "@authUrl@":/realtime/authentication#token-upgrading and "@authCallback@":/realtime/authentication#token-upgrading.

h4. 7. Using the correct client library SDK - Choosing between Realtime, REST, MQTT and others 

* Want to maintain a persistent connection with Ably's Realtime platform, so you can subscribe to messages sent on a channel, or be notified whenever the presence set changes? Use the "realtime library":/realtime.
* Want to just publish data to the platform and don't need to subscribe or manage channel attachment? Use the "REST library":/rest.
* Want to publish at very high volumes or with the lowest possible latency? "The realtime libary can publish at higher volumes (due to message pipelining) and lower latencies than is possible with the REST library":https://support.ably.io/solution/articles/3000060319-should-i-use-the-rest-or-realtime-library.
* Want to get one-time info about the presence set of a channel? Use the "REST library":/rest.
* Want to set up realtime communication with IoT devices on platforms for which there's no native Ably client library available? Use the "MQTT protocol adapter":/mqtt.
* Want to migrate from PubNub/Pusher? Use the relevant "protocol adapter":/adapters to "ease the pain of migration":https://support.ably.io/solution/articles/3000054127-can-you-help-ease-the-pain-of-migration-from-another-realtime-service: you can switch to Ably right away while sticking with your current client libraries, and gradually migrate to native Ably clients.

h4. 8. Subscribing to events on the server-side

* Subscribing to events on the server side using the standard Pub/Sub pattern can be a bad idea for a number of reasons such as additional layer of latency, duplicate events among multiple servers etc, as explained in this "blog article":https://blog.ably.io/message-queues-the-right-way-to-process-and-work-with-realtime-data-on-your-servers-2d15985301f8. With Message Queues, you can set up multiple worker servers to distribute the load of the messages received from Ably while ensuring each of the messages gets processed exactly once by any one of your worker servers.

h4. 9. WebHooks/Reactor Functions vs. Message Queues when to use which?

* "WebHooks":/general/webhooks and "Reactor Functions":/general/functions work well for low or medium message volumes, but "Reactor Queues":/general/queues will scale better to high message volumes. For very high volumes, we recommend using "Reactor Firehose":/general/firehose.

h4. 10. Multiplexing channels

* You should almost always instantiate a single Ably client library instance per device, web page or server. Don't forget that the Client Library SDK can "multiplex":https://support.ably.io/support/solutions/articles/3000058406-do-you-support-channel-groups-and-multiplexing many channels over a single connection. Ensuring this maximises throughput, minimises bandwidth consumption and reduces power & battery drain.

h4. 11. Limiting the effect of a security compromise using the principle of least privilege

* Using the available "authentication methods":/general/authentication in Ably, you can choose the permissions or capabilities to be given to a client. You can do this by restricting the permissions on the API key as well as restricting the permissions your auth server grants to that API key whilst granting a token request. You can restrict the channels that a client can access (including with wildcards), as well as the operations the client can perform within those channels, using "capabilities":/general/authentication#capabilities-explained.
* Always make sure to limit the capabilities given to a client to only what's required by the client to do their job. This prevents any unexpected behaviour by a client and increases the security of your application. This is called the principle of least privilege.

h4. 12. Efficient use of channels

Whilst we recommend that you use channels to distribute work more evenly across the cluster, there is an associated cost for a high number of channels. Here are some considerations that may help you with your channel usage design:

* Don't use different channels just to indicate different types of data or different events, if they're all going to the same set of clients. Use one channel, and distinguish between the different events using the message name.
* Channels are the unit of security and scalability. If you are sending some data that must not be shared with certain clients, make sure it's on a channel that those clients don't have the capabilities to attach to.
* Be aware that each channel can support a maximum of 100 messages per second.

h4. 13. Embedding client ID in the token to ensure trust

* You can embed a client ID in the token issued to your clients. This ensures that all the messages published from these clients contain their trusted client ID. This serves as an identification when they are present on channels.