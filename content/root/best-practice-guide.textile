---
title: Best Practice Guide
section: root
index: 30
jump_to:
  Contents:
    - Ably 101
    - Using Ably like a pro
---

h2(#title). Ably Best Practice Guide

This best practice guide aims to quickly help you understand the best way to make use of Ably's Realtime platform for your applications. These recommendations include some important considerations that may otherwise be easily missed when reading through our documentation. 

This guide consists of the following two sections:

* "Ably 101":#ably-101 - Key concepts that you must understand before moving on to the best practice recommendations.
* "Using Ably like a pro":#using-ably-like-a-pro - Recommendations that we've compiled as per our experience with developers to help you avoid common mistakes or misunderstandings.

h3(#ably-101). Ably 101

Ably Realtime is a cloud-based platform that allows you to easily integrate realtime functionality into your applications. Just plug and play.

h4(#pubsub). Publish and Subscribe (Pub/Sub)

Ably allows you to publish data to a named "channel":/realtime/channels-messages on it's Realtime platform, and all the clients subscribed to that very channel will receive this data in realtime i.e. as it is being published.

h4(#notifications). Notifications 

Ably offers the "Push Notifications":/realtime/push feature which allows you to send notifications to your clients even when they are not using your application at the time, or in other words, not connected to Ably. This can be implemented on both mobile devices and browsers. Ably also offers a smart variation known as "Smart Notifications":/general/smart-notifications using which you can make the notifications most effective based on your user's connection state, their active device or even their current context within your application.

h4(#presence). Presence

Your clients can attach to a presence channel using Ably's "Presence":/realtime/presence feature and announce to the rest of the users that they are present on a channel. This is very useful, for example, in chat apps to indicate a member is online, or with IoT devices to indicate a device is online and connected. Clients can subscribe to realtime presence changes on channels, such as members entering or leaving, and respond to these events accordingly.

h4(#rest-or-realtime). Realtime vs REST

Ably provides two types of client libraries. "Realtime":/realtime libraries maintain a persistent connection to Ably and can be considered stateful, whereas "REST":/rest libraries issue HTTP requests to the Ably platform and are stateless.

h4(#auth). Authentication and Encryption

Ably offers two main authentication strategies. "Basic Authentication":/general/authentication#basic-authentication is very easy to set up and requires the API key to be used by your clients. "Token Authentication":/general/authentication#token-authentication allows you to connect to your auth server that in turns connects to Ably using the API key but allows your clients to handle authentication using the short-lived tokens. Tokens provide a secure way to pass information over the internet. They make sure that the actual API key is never exposed to your end clients but remains with your auth server. Furthermore, you can use JWT Authentication as part of Token Authentication if you prefer to use a single auth strategy across all the third party services that you use. Ably also provides an option to "encrypt your messages":/realtime/encryption within the Ably system. 

h3(#using-ably-like-a-pro). Using Ably like a pro

h4. 1. Channels that you attach to, automatically receive messages from Ably even without a subscribe listener

* Once a channel is attached, assuming the client has permission to subscribe to messages, Ably will immediately start sending published messages to that client irrespective of whether there are any subscribe listeners registered on that client or not. A common misunderstanding is that only after a client has "subscribed":/realtime/channels-messages#message-subscription to a channel will Ably start sending messages to that client. This is not the case as registering a listener with a channel subscribe operation is a client-side operation only and is not communicated to Ably. 

h4. 2. Use separate channels when you want messages to be sent to different sets of subscribers

* Ably pushes all the data published on a channel to every subscriber attached to that channel. Subscribers can choose to only subscribe to events with a certain message name, but that filtering is done on the client side. If you have messages that don't need to be sent to some clients at all, you're often better off using a separate channel for those instead of implementing a filter. This way, you won't be sending unnecessary messages that count towards your package limit. However, in some cases where you wish to trigger different listeners for different events, setting up a single channel and filtering the messages client side would be more sensible. An example is shown below:

```[javascript]
var sportsChannel = realtime.channels.get("sport");
//publish
sportsChannel.publish("update", { "team": "Man United" });
sportsChannel.publish("add", { "team": "Chelsea" });

//subscribe filters
sportsChannel.subscribe("update", function(){
  //do one thing
});
sportsChannel.subscribe("add", function(){
  //do another thing
});
```

h4. 3. Being present without subscribing to presence events

* If you want lots of people to be present, but not necessarily listen for "presence change events":/realtime/presence#presence-states, you should use token capabilities to prevent all users from receiving presence notifications but ensure they are allowed to enter the presence set. This is a common scenario when you just want to know how many people are present on a channel at any point in time. An example of such a differential token capability is shown below:

```json
{
  "presenceChannel": ["publish", "presence"],
  "chat": ["presence", "history", "subscribe],
}
```

h4. 4. Handling connection and channel state-change events

Ably's Realtime SDKs automatically handle disruptions such as network disconnections, so you don't need to manually handle reconnection. The library emits:

* "Connection":/realtime/connection#connection-states state change events such as @initialized@, @connecting@, etc. You can set up listeners for these state change events in order to handle connection failures such as those occuring due to failed authentication. An example of handling connection state-change event is shown below:

```javascript
realtime.connection.on(function(stateChange) {
  console.log('New connection state is ' + stateChange.current);
});
```

* "Channel":/realtime/channels-messages#channel-states state change events for various channel states such as @initialized@, @attaching@, etc. Similar to connection state changes, you can set up listeners for channel state changes in case you'd like to be informed about what's happening. For example, if you want to know whenever the library has lost message continuity on a channel due to being disconnected for more than two minutes. An example of handling channel state-change events is shown below:

```javascript
var myListener = function(stateChange) {
  console.log('channel state is ' + stateChange.current);
  console.log('previous state was ' + stateChange.previous);
});
channel.on(myListener);
```

However, while registering listeners for both connection and channel state change events, bear in mind that certain repeating states might add new listeners everytime. For instance, registering a listener for @on(connected)@ adds a new listener every time the client becomes connected, even if this is a reconection after being offline for a while, which in most cases might not be something you intended to do.

h4. 5. Using the API key on the client side

* Ably's "Basic Authentication":/general/authentication#basic-authentication method is the easiest way to authenticate your clients on the Ably Realtime platform. However, it directly exposes the API key in the source code. When you use it on the client side, any entity that interacts with the client could view your API key and potentially misuse it. If you can run an auth server, we recommend using "Token Authentication":/general/authentication#token-authentication instead. In this method, your auth server is expected to use the API key to raise a token request from Ably, the token in turn, can be used by your end clients in the authentication step, thus eliminating the chance of misusing an exposed API key. "Read more":/general/authentication#selecting-auth about selecting an authentication mechanism.

h4. 6. Ensuring tokens are auto-renewable

* Tokens are short-lived i.e. they expire after a given time. It is almost never correct to provide a token to a client library without ensuring the client library has a means to get a new token automatically when it needs one. The Ably client library SDKs provide two mechanisms in the "ClientOptions":/realtime/authentication#token-authentication so that they can obtain tokens automatically using either "@authUrl@":/realtime/authentication#token-upgrading or the "@authCallback@":/realtime/authentication#token-upgrading.

h4. 7. Using the correct client library SDK - Choosing between Realtime, REST, MQTT and others 

* If you want to maintain a persistent connection with Ably's Realtime platform in order to subscribe to messages sent on a channel, or be notified whenever the presence set changes, you need to use the "realtime library":/realtime.
* If you want to just publish data to the platform and don't need to subscribe or manage channel attachment, you can the "REST library":/rest.
* If you want to publish at very high volumes or with the lowest possible latency in realtime, you must know that "Ably's realtime libary can publish at higher volumes and lower latencies than is possible with the REST library due to message pipelining":https://support.ably.io/solution/articles/3000060319-should-i-use-the-rest-or-realtime-library.
* If you want to get one-time info about the presence set of a channel, you can use the "REST library":/rest.
* If you want to set up realtime communication with IoT devices on platforms for which there's no native Ably client library available, you can the "MQTT protocol adapter":/mqtt.
* If you wish to migrate from PubNub/Pusher to Ably, you can use the relevant "protocol adapter":/adapters to "easily":https://support.ably.io/solution/articles/3000054127-can-you-help-ease-the-pain-of-migration-from-another-realtime-service switch to Ably right away and gradually migrate to using native Ably client SDKs.

h4. 8. Subscribing to events on the server-side

* Subscribing to events on the server side using the standard Pub/Sub pattern can be a bad idea for a number of reasons such as an added layer of latency, duplicacy of events among multiple servers etc, as explained in this "blog article":https://blog.ably.io/message-queues-the-right-way-to-process-and-work-with-realtime-data-on-your-servers-2d15985301f8. With Message Queues, you can have multiple worker servers and let Ably distribute the load of the messages received from publishers. Ably also ensures that each of the messages gets processed exactly once by any one of your worker servers.

h4. 9. WebHooks/Reactor Functions vs. Message Queues when to use which?

* "WebHooks":/general/webhooks and "Reactor Functions":/general/functions work well for low or medium message volumes i.e ~20/s, but "Reactor Queues":/general/queues will scale better to high message volumes i.e ~200/s. For volumes higher than that, we recommend using "Reactor Firehose":/general/firehose.

h4. 10. Multiplexing channels

* You should almost always instantiate a single Ably client library instance per device, web page or server. Don't forget that the Client Library SDK can "multiplex":https://support.ably.io/support/solutions/articles/3000058406-do-you-support-channel-groups-and-multiplexing many channels over a single connection. This maximises throughput, minimises bandwidth consumption and reduces power & battery drain.

h4. 11. Limiting the effect of a security compromise using the principle of least privilege

* Using the available "authentication methods":/general/authentication in Ably, you can choose the permissions or capabilities to be given to a client. You can do this by restricting the permissions on the API key as well as restricting the permissions that your auth server grants to this API key whilst sending a token request. You can restrict the channels that a client can access (using wildcards), as well as the operations the client can perform within those channels, using "capabilities":/general/authentication#capabilities-explained.
* Always make sure to limit the capabilities given to a client to only what's required by the client to do their job. This prevents any unexpected behaviour by a client and increases the security of your application. This is called the principle of least privilege.

h4. 12. Efficient use of channels

Whilst we recommend that you use channels to distribute work more evenly across the cluster, there is an associated cost for a high number of channels. Here are some considerations that may help you with your channel usage design:

* Don't use different channels just to indicate different types of data or different events, if they're all going to the same set of clients. Use one channel, and distinguish between the different events using the message name.
* Channels are the unit of security and scalability. If you are sending some data that must not be shared with certain clients, make sure it's on a channel that those clients don't have the capabilities to attach to.
* Be aware that each channel can support a maximum of 100 messages per second.

h4. 13. Embedding client ID in the token to ensure trust

* A clientID serves as an identification for your clients when they are present on a channel. Your clients can set their own client ID, but in that case, there's a possibility that some of your clients can pretend to be someone else. To prevent this, you can embed a client ID in the token issued to your clients from your auth server. Doing so ensures that the client ID is set by your auth server, thus eliminating the chance of the end clients emulating as others.