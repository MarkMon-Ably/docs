---
title: Presence
section: realtime
index: 40
jump_to:
  Help with:
    - Getting started#getting-started
    - Presence
    - Presence states and events#presence-states
    - Presence data
    - Presence member list
    - Presence history
    - Multiple client IDs#presence-multiple-client-id
  Presence API reference:
    - enter
    - enterClient#enter-client
    - update
    - updateClient#update-client
    - leave
    - leaveClient#leave-client
    - subscribe
    - unsubscribe
    - get
  Related types:
    - PresenceMessage#presence-message
    - PresenceListener#presence-listener
---

Presence enables clients to be aware of other clients that are currently "present" on a channel. Each member present on a channel has a unique self-assigned client identifier and system-assigned connection identifier, along with an optional payload that can be used to describe the member's status or attributes. Presence allows you to quickly build apps such as chat rooms and multiplayer games by automatically keeping track of who is present in real time across any device.

h2(#getting-started). Getting started

The @Presence@ object provides a straightforward API to subscribe to presence events such as members entering or leaving, retrieve a list of members present, or register the connected client as "present" on a channel. Here is a simple presence example using the "@presence@":/realtime/channels-messages#presence <span lang="default">property</span><span lang="java">field</span><span lang="ruby">attribute</span> of the "@Channel@":/realtime/channels-messages object to enter a channel and subscribe to presence events.

```[javascript](code-editor:realtime/presence-simple)
  var realtime = new Ably.Realtime({
    key: '{{API_KEY}}',
    clientId: 'bob' }
  );
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.presence.subscribe('enter', function(member) {
    alert('Member ' + member.clientId + ' entered');
  });
  channel.presence.enter();
```

```[nodejs](code-editor:realtime/presence-simple)
  var Ably = require('ably-js');
  var realtime = new Ably.Realtime({
    key: '{{API_KEY}}',
    clientId: 'bob' }
  );
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.presence.subscribe('enter', function(member) {
    alert('Member ' + member.clientId + ' entered');
  });
  channel.presence.enter();
```

```[ruby]
  realtime = Ably::Realtime.new(key: '{{API_KEY}}', client_id: 'bob')
  channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
  channel.presence.subscribe(:enter) do |member|
    puts "Member #{member.client_id} entered"
  end
  channel.presence.enter
```

```[java]
  ClientOptions options = new ClientOptions("{{API_KEY}}");
  options.clientId = "bob";
  AblyRealtime realtime = new AblyRealtime(options);
  Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
  channel.presence.subscribe(new PresenceListener() {
    @Override
    public void onPresenceMessage(PresenceMessage[] messages) {
      PresenceMessage member = messages[0]; // use only first for this example
      System.out.println("Member " + member.clientId + " : " + member.action.toString());
    }
  });
  channel.presence.enter(null, new CompletionListener());
```

h2(#presence). Presence

In order to be present on a channel, a client must "be identified by having a client ID":https://support.ably.io/solution/articles/3000038608-authenticated-and-identified-clients, "have permission to be present":https://support.ably.io/solution/articles/3000048535-using-capabilities-to-manage-client-access-privileges-on-channels, and be attached to the channel. For simplicity, the library will implicitly attach to a channel when entering or subscribing to presence events. Clients are assigned a <span lang="default">"@clientId@":/realtime/usage#client-id</span><span lang="ruby">"@client_id@":/realtime/usage#client-id</span> when using token authentication, "find out more about token authentication":/general/authentication#token-authentication.

A single <span lang="default">"@clientId@":/realtime/usage#client-id</span><span lang="ruby">"@client_id@":/realtime/usage#client-id</span> may be present multiple times on the same channel via different client connections. As far as Ably is concerned, these are different members of the presence set for the channel, however they will be differentiated by their unique <span lang="default">"@connectionId@":/realtime/connection#id</span><span lang="ruby">"@connection_id@":/realtime/connection/#id</span>. For example, if a client with ID "Sarah" is connected to a chat channel on both a desktop and a mobile device simultaneously, "Sarah" will be present twice in the member set with the same client ID, yet will have two unique connection IDs. A member of the presence set is therefore unique by the combination of the <span lang="default">"@clientId@":/realtime/usage#client-id</span><span lang="ruby">"@client_id@":/realtime/usage#client-id</span> and <span lang="default">"@connectionId@":/realtime/connection#id</span><span lang="ruby">"@connection_id@":/realtime/connection/#id</span> strings.

h3(#presence-states). Presence states and events

Whenever a member enters or leaves a channel, or updates "their member data":#member-data, a presence event is emitted to all presence subscribers on that channel. Subscribing to presence events makes it incredibly easy to build an app that shows, in real time, any changes to clients connected to Ably and present on a channel.

The following presence events are emitted:

- <span lang="ruby">@:enter@</span><span lang="java">@Action.ENTER@</span><span lang="default">@enter@</span> := A new member has entered the channel

- <span lang="ruby">@:leave@</span><span lang="java">@Action.LEAVE@</span><span lang="default">@leave@</span> := A member who was present has now left the channel. This may be a result of an explicit request to leave or implicitly when detaching from the channel. Alternatively, if a member's connection is abruptly disconnected and they do not resume their connection within a minute, Ably treats this as a leave event as the client is no longer present

- <span lang="ruby">@:update@</span><span lang="java">@Action.UPDATE@</span><span lang="default">@update@</span> := An already present member has updated their "member data":#member-data. Being notified of member data updates can be very useful, for example, it can be used to update the status of a user when they are typing a message

- <span lang="ruby">@:present@</span><span lang="java">@Action.PRESENT@</span><span lang="default">@present@</span> := When subscribing to presence events on a channel that already has members present, this event is emitted for every member already present on the channel before the subscribe listener was registered

"View a presence states and events example":<%= JsBins.url_for('realtime/presence-events') %>

h3(#member-data). Member data

In addition to the <span lang="default">"@clientId@":/realtime/usage#client-id</span><span lang="ruby">"@client_id@":/realtime/usage#client-id</span> for members on a channel, it is also possible to include data when entering a channel. Clients can "update":#update their data at any point which will be broadcasted to all presence subscribers as an <span lang="ruby">@:update@</span><span lang="java">@Action.UPDATE@</span><span lang="default">@update@</span> event.

```[jsall]
/* Subscribe to presence enter events */
channel.presence.on('enter', function(member) {
  console.log(member.data); // => not moving
});

/* Subscribe to presence update events */
channel.presence.on('update', function(member) {
  console.log(member.data); // => travelling North
});

/* Enter this client with data and update once entered */
channel.presence.enter('not moving', function(err) {
  channel.presence.update('travelling North');
});
```

```[java]
/* Subscribe to presence enter and update events */
channel.presence.subscribe(new PresenceListener() {
  @Override
  public void onPresenceMessage(PresenceMessage[] messages) {
    PresenceMessage member = messages[0]; // use only first for this example
    switch (member.action) {
      case ENTER: {
        System.out.println(member.data); // => not moving
        break;
      }
      case UPDATE: {
        System.out.println(member.data); // => travelling North
        break;
      }
    }
  }
});

/* Enter this client with data and update once entered */
channel.presence.enter("not moving", new CompletionListener() {
  @Override
  public void onSuccess() {
    channel.presence.update("travelling North", new CompletionListener());
  }
});
```

```[ruby]
# Subscribe to presence enter events
channel.presence.subscribe(:enter) do |member|
  puts member.data # => not moving
end

# Subscribe to presence update events
channel.presence.subscribe(:update) do |member|
  puts member.data # => travelling North
end

# Enter this client with data and update once entered
channel.presence.enter(data: 'not moving') do
  channel.presence.update(data: 'travelling North')
end
```

h3(#member-list). Presence member list

The @Presence@ object exposes a "@get@":#get method allowing a client to retrieve an array of all members present on the channel. The Ably client is responsible for keeping track of the presence set from the time that the channel is attached; an up to date presence set is pushed to the client following attach and the presence set is updated on each subsequent presence event. Thus @get@ returns the already-known presence set retained in memory and does not trigger a new request to the Ably service.

```[jsall]
channel.presence.get(function(err, members) {
  console.log('There are ' + members.length + ' members on this channel');
  console.log('The first member has client ID: ' + members[0].clientId);
});
```

```[ruby]
channel.presence.get do |members|
  puts "There are #{members.size} members on this channel"
  puts "The first member has client ID: #{members.first.client_id}"
end
```

```[java]
PresenceMessage[] members = channel.presence.get();
System.out.println("There are " + members.length + " members on this channel");
System.out.println("The first member has client ID: " + members[0].clientId);
```

h3(#presence-history). Presence History

The @Presence@ object exposes a "@history@":#history method allowing a client to retrieve historical presence events on the channel. Presence history can be used to return continuous presence event history up to the exact point a realtime channel was attached.

History provides access to instantaneous "live" history as well as the longer term persisted history for presence channels. If "persisted history":/realtime/history#persisted-history is enabled for the channel, then presence events will "typically be stored for 24 - 72 hours":https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for. If persisted history is not enabled, Ably retains the last two minutes of presence event history in memory.

The following example retrieves the first two pages of historical presence events published up until the point the channel was attached.

bc[jsall]. channel.attach(function() {
  var presence = channel.presence;
  presence.history({ untilAttach: true }, function(err, resultPage) {
    if(err) {
      console.log('Unable to get presence history; err = ' + err.message);
    } else {
      console.log(resultPage.items.length + ' presence events received in first page');
      if(resultPage.hasNext()) {
        resultPage.next(function(err, nextPage) { ... });
      }
  });
});

bc[ruby]. channel.attach do
  presence = channel.presence
  presence.history(until_attach: true) do |result_page|
    puts "#{result_page.items.length} presence events received in first page"
    if result_page.has_next?
      result_page.next { |next_page| ... }
    end
  end
end

```[java]
PaginatedResult<PresenceMessage> resultPage = channel.presence.history(null);
System.out.println(resultPage.items().length + " presence events received in first page");
if(resultPage.hasNext()) {
  PaginatedResult<PresenceMessage> nextPage = resultPage.next();
  System.out.println(nextPage.items().length + " presence events received in 2nd page");
}
```

See the "history":/realtime/history documentation for further details of the supported query parameters.

h3(#presence-multiple-client-id). Managing multiple client IDs

An Ably client instance might, if on an application server for example, publish messages and be present on channels on behalf of multiple distinct "client IDs":/realtime/usage#client-id. The channel's @Presence@ object therefore also supports methods that enable presence messages to be emitted for a <span lang="default">"@clientId@":/realtime/usage#client-id</span><span lang="ruby">"@client_id@":/realtime/usage#client-id</span> specified at the time of the call, rather than implicitly based on the <span lang="default">"@clientId@":/realtime/usage#client-id</span><span lang="ruby">"@client_id@":/realtime/usage#client-id</span> "specified when the library is instanced or authenticated":/realtime/usage#client-id.

In order to be able to publish presence changes for arbitrary client IDs, the client library must have been instanced either with an "API key":https://support.ably.io/solution/articles/3000030054-what-is-an-app-api-key, or with a "token bound to a wildcard client ID":https://support.ably.io/solution/articles/3000048586-can-a-client-emulate-any-client-id-i-e-use-a-wildcard-client-id. Also,

```[jsall](code-editor:realtime/presence-multiple-client-id)
var rest = new Ably.Rest({ key: '{{API_KEY}}' });
/* request a wildcard token */
rest.auth.requestToken({ clientId: '*' }, function(err, token) {
  var realtime = new Ably.Realtime({ token: token });
  var channel = realtime.channels.get('realtime-chat');

  channel.presence.subscribe('enter', function(member) {
    console.log(member.client_id + 'entered realtime-chat');
  });

  channel.presence.enterClient('Bob'); // => Bob entered realtime-chat
  channel.presence.enterClient('Mary'); // => Mary entered realtime-chat
});
```

```[ruby]
rest = Ably::Rest.new(key: '{{API_KEY}}')
# request a wildcard token
rest.auth.requestToken(clientId: '*') do |token|
  realtime = Ably::Realtime.new(token: token)
  channel = realtime.channels.get('realtime-chat')

  channel.presence.subscribe(:enter) do |member|
    puts "#{member.client_id} entered realtime-chat"
  end

  channel.presence.enter_client 'Bob' # => Bob entered realtime-chat
  channel.presence.enter_client 'Mary' # => Mary entered realtime-chat
end
```

```[java]
/* request a wildcard token */
AblyRest rest = new AblyRest('{{API_KEY}}');
TokenParams params = new TokenParams();
params.clientId = "*";
ClientOptions options = new ClientOptions();
options.tokenDetails = rest.auth.requestToken(null, params);

AblyRealtime realtime = new AblyRealtime(options);
Channel channel = realtime.channels.get("realtime-chat");

channel.presence.subscribe(new PresenceListener() {
  @Override
  public void onPresenceMessage(PresenceMessage[] messages) {
    PresenceMessage member = messages[0]; /* use only first for this example */
    System.out.println(member.clientId + " entered realtime-chat");
  }
});

CompletionListener noop = new CompletionListener();
channel.presence.enterClient("Bob", noop); /* => Bob entered realtime-chat */
channel.presence.enterClient('Mary', noop); /* => Mary entered realtime-chat */
```

h1. API Reference

inline-toc.
  Presence reference:
    - Methods:
      - enter
      - enterClient#enter-client
      - update
      - updateClient#update-client
      - leave
      - leaveClient#leave-client
      - subscribe
      - unsubscribe
      - get
      - history
    - Related types:
      - PresenceMessage#presence-message
      - PresenceListener#presence-listener

h2. Methods

h6(#enter)[default]. enter(clientData, callback)

h6(#enter)[java]. public void enter(Object clientData, CompletionListener listener)

Enter this presence channel. The Ably library must have been initialised with a <span lang="jsall">clientId</span><span lang="ruby">client_id</span>, and must have been supplied either with a key, or a token bound to that <span lang="jsall">clientId</span><span lang="ruby">client_id</span>.

This method sends a @PresenceMessage@ for the client's <span lang="jsall">clientId</span><span lang="ruby">client_id</span> and optional <span lang="jsall">clientData</span><span lang="ruby">client_data</span>. A <span lang="default">callback</span><span lang="java">listener</span> may optionally be passed in to this call to be notified of success or failure of the operation.

h4. Parameters

- <span lang="java">Object</span>clientData := An optional payload for the message.

- <div lang="jsall">callback</div> := Callback to be called on completion.

- <div lang="java">listener</div> := Listener to be notified on completion.

h6(#enter-client)[default]. enterClient(clientId, clientData, callback)

h6(#enter-client)[java]. public void enter(String clientId, Object clientData, CompletionListener listener)

Enter this presence channel for the given clientId. This method is provided to support connections (eg connections from application server instances) that act on behalf of multiple clientIds. In order to be able to enter the channel with this method, the Ably library must have been instanced either with a key, or with a token bound to the wildcard clientId.

This method sends a @PresenceMessage@ for the given <span lang="jsall">clientId</span><span lang="ruby">client_id</span> and optional <span lang="jsall">clientData</span><span lang="ruby">client_data</span>. A <span lang="default">callback</span><span lang="java">listener</span> may optionally be passed in to this call to be notified of success or failure of the operation.

h4. Parameters

- <span lang="java">String</span>clientId := The clientId for the message.

- <span lang="java">Object</span>clientData := An optional payload for the message.

- <div lang="jsall">callback</div> := Callback to be called on completion.

- <div lang="java">listener</div> := Listener to be notified on completion.

h6(#update)[default]. update(clientData, callback)

h6(#update)[java]. public void update(Object clientData, CompletionListener listener)

Update the presence data for this client. The Ably library must have been initialised with a <span lang="jsall">clientId</span><span lang="ruby">client_id</span>, and must have been supplied either with a key, or a token bound to that <span lang="jsall">clientId</span><span lang="ruby">client_id</span>.

This method sends a @PresenceMessage@ for the client's <span lang="jsall">clientId</span><span lang="ruby">client_id</span> and optional <span lang="jsall">clientData</span><span lang="ruby">client_data</span>. A <span lang="default">callback</span><span lang="java">listener</span> may optionally be passed in to this call to be notified of success or failure of the operation.

h4. Parameters

- <span lang="java">Object</span>clientData := An optional payload for the message.

- <div lang="jsall">callback</div> := Callback to be called on completion.

- <div lang="java">listener</div> := Listener to be notified on completion.

h6(#update-client)[default]. updateClient(clientId, clientData, callback)

h6(#update-client)[java]. public void updateClient(String clientId, Object clientData, CompletionListener listener)

Enter update the <span lang="jsall">clientData</span><span lang="ruby">client_data</span> for the given present clientId on this presence channel. This is the analogue of <span lang="jsall">enterClient</span><span lang="ruby">enter_client</span>, for the update action.

h4. Parameters

- <span lang="java">String</span>clientId := The clientId for the message.

- <span lang="java">Object</span>clientData := An optional payload for the message.

- <div lang="jsall">callback</div> := Callback to be called on completion.

- <div lang="java">listener</div> := Listener to be notified on completion.

h6(#leave)[default]. leave(callback)

h6(#leave)[java]. public void leave(CompletionListener listener)

Leave this presence channel. This is subject to the same authentication requirements as the "enter":#enter method above.

This method sends a @PresenceMessage@ for the client's <span lang="jsall">clientId</span><span lang="ruby">client_id</span> and optional <span lang="jsall">clientData</span><span lang="ruby">client_data</span>. A <span lang="default">callback</span><span lang="java">listener</span> may optionally be passed in to this call to be notified of success or failure of the operation.

h4. Parameters

- <div lang="jsall">callback</div> := Callback to be called on completion.

- <div lang="java">listener</div> := Listener to be notified on completion.

h6(#leave-client)[default]. leaveClient(clientId, callback)

h6(#leave-client)[java]. public void leaveClient(String clientId, CompletionListener listener)

This is the analogue of "enterClient":#enter-client, for the @leave@ action.

h4. Parameters

- <span lang="java">String</span>clientId := The clientId for the message.

- <div lang="jsall">callback</div> := Callback to be called on completion.

- <div lang="java">listener</div> := Listener to be notified on completion.

h6(#subscribe)[default]. subscribe(listener)

h6(#subscribe)[java]. public void subscribe(PresenceListener listener)

Subscribe to presence messages for this channel. The caller supplies <span lang="default">a listener function</span><span lang="java">an implementation of the PresenceListener interface</span>, which is called each time one or more messages arrives on the channel.

h4. Parameters

- <div lang="jsall">listener</div> := The listener function to call for each message.

- <div lang="java">listener</div> := The MessageListener to be notified on completion.

h6(#unsubscribe)[default]. unsubscribe(listener)

h6(#unsubscribe)[java]. public void unsubscribe(PresenceListener listener)

Unsubscribe a previously subscribed listener.

h4. Parameters

- <div lang="jsall">listener</div> := The listener function registered on subscription.

- <div lang="java">listener</div> := The PresenceListener registered on subscription.

h6(#get)[default]. get()

h6(#get)[java]. public PresenceMessage[] get()

Get the current presence set for this channel. This returns synchronously with the presence set already known by the client.

h6(#history). history

bq(definition).
  default: presence.history(params, callback)
  ruby:    presence.history(options) → json_result
  java:    public PaginatedResult&lt;PresenceMessage&gt; history(Param[] params)

Get presence history for this channel.

h4. Parameters

- params := an optional object containing the query parameters, as specified in the "history":/realtime/history API documentation.
- <div lang="jsall">callback</div> := is a function of the form: @callback(err, messages, relParams)@
where:
<ul>
<li>@err@ contains an error value on the case of an error response as defined in the "REST API":/rest-api#common documentation</li>
<li>on success, @messages@ contains the query result as an array of PresenceMessage objects.</li>
<li>where applicable, @relParams@ is a map containing query params for each of the pagination links in the query response (see below).</li>
</ul>

Further details of the supported query params are in the "history API":/realtime/history documentation.

<div lang="java">
h4. Returns

On success, the returned "PaginatedResult":#paginated-result encapsulates a collection of @PresenceMessage@ objects corresponding to the current page of results, and also provides query parameters for any applicable related (eg @first@ or @next@ result pages).

Failure to retrieve the history will raise an @AblyException@.

</div>

<div lang="ruby">
h4. Returns

On success, @json_result@ contains an array of results whose type corresponds to the result type for the request granularity as specified in "REST API":/rest-api/#message-history.

Example @json_result@:

```[json]
[{
  "name": "<event name>",
  "channel": "<channel id>",
  "data": "<message payload>",
  "timestamp": "<message timestamp>"
}]
```

Failure to retrieve the history will raise an exception - typical exceptions include:

* @Ably::NetworkUnavailableException@
* @Ably::QuotaExceededException@
* @Ably::AuthenticationFailureException@

</div>

<div lang="jsall">

h4. Pagination

A paginated result is indicated in the @relParams@ callback argument. For each available link, @relParams@ contains a map of params to pass to a subsequent @history()@ call.
  Example @relParams@:

```[json]
[{
  "first": {"start": 1380794880000, "end": 138079488105, ...},
  "current": {"start": 1380794880000, "end": 138079488105, ...},
  "next": {"start": 1380794880000, "end": 138079488105, ...}
}]
```

Further details of the paginated response are in the "history API":/realtime/history documentation.
</div>

h2(#presence-message). PresenceMessage

A @PresenceMessage@ encapsulates an individual presence update sent or received in Ably. A presence message has the following members.

- <span lang="java">String</span>clientId := The id of the client associated with the update. This <span lang="default">property</span><span lang="java">field</span> is populated by the system, where the clientId is known, for messages delivered to subscribers. It is not required to populate the clientId of a message before publishing it.

- <span lang="java">String</span>connectionId := A unique id for the client associated with the update, to disambiguate in the case that a single clientId is simultaneously present multiple times (eg on different connections). This <span lang="default">property</span><span lang="java">field</span> is populated by the system, where the connectionId is known, for messages delivered to subscribers.

- <span lang="java">Object</span>clientData := An optional message payload for a status line or other data associated with the presence update. The data may be one of the supported payload datatypes.

h2(#presence-listener). PresenceListener

<div lang="jsall">
A @PresenceListener@ function may be subscribed for all presence messages received on the channel. The message is passed as the first argument to the listener.
</div>
<div lang="java">
A implementation of the @PresenceListener@ interface may be registered to be notified of  arrival of presence messages on the channel. A @PresenceMessage[]@ is passed as the first argument of the listener's @onPresenceMessage@ method whenever a presence message is received on the channel.
</div>

<div lang="java">
h2(#paginated-result). PaginatedResult

A @PaginatedResult@ is an interface that represents the result of a query that supports pagination. An instance of @PaginatedResult@ encapsulates a collection of @PresenceMessage@ objects representing the current page of results, and provides the means - in the form of @Param[]@ to perform queries for subsequent or related pages.

- public PresenceMessage[] asArray() := Returns the current page of results as an Array.
- public List&lt;PresenceMessage&gt; := Returns the current page of results as a List.
- public Param[] getFirst() := Returns the params to pass to a @history()@ call to reproduce the first call in this paginated sequence.
- public Param[] getCurrent() := Returns the params to pass to a @history()@ call to reproduce the current call in this paginated sequence.
- public Param[] getNext() := Returns the params to pass to a @history()@ call to reproduce the next call in this paginated sequence.

</div>
