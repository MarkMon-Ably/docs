---
title: History
section: realtime
index: 50
jump_to:
  Help with:
    - Getting started
    - Channel and Presence history#channel-and-presence
    - Persisted history
    - Continuous history
  API reference:
    - Message history#message
    - Presence history#presence
  Related types:
    - Message
    - PresenceMessage#presence-message
    - Presence action
    - PaginatedResult#paginated-result
---

The Realtime client library provides message and presence event history for channels. Channel history can be used to return continuous message history up to the exact point a realtime channel was attached, and combines both instantaneous "live" history as well as the longer term "persisted history":#persisted-history. If "persisted history":#persisted-history is enabled for the channel, then messages will "typically be stored for 24 - 72 hours on disk":https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for. If persisted history is not enabled, Ably retains the last two minutes of instantaneous "live" message history in memory.

h2(#getting-started). Getting started

The Ably Realtime client library provides a straightforward API to retrieve "paginated":#paginated-result message or presence event history. Each page of history, by default, contains up to 100 messages. Message ordering, by default, is from most recent to oldest.

```[jsall](code-editor:realtime/channel-history)
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.publish('example', 'message data', function(err) {
    channel.history(function(err, resultPage) {
      var lastMessage = resultPage.items[0];
      alert('Last message: ' + lastMessage.id + ' - ' + lastMessage.data);
    });
  });
```

```[ruby]
  realtime = Ably::Realtime.new('{{API_KEY}}')
  channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
  channel.publish 'example', 'message data' do
    channel.history do |result_page|
      last_message = result_page.items.last
      puts "Last message: #{last_message.message.id} - #{last_message.data}")
    end
  end
```

```[java]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
  channel.publish("example", "message data", new CompletionListener() {
    @Override
    public void onError(ErrorInfo reason) {
      System.out.println("Unable to publish message; err = " + reason.message);
    }
    @Override
    public void onSuccess() {
      PaginatedResult<Message> resultPage = channel.history(null);
      Message lastMessage = resultPage.items[0];
      System.out.println("Last message: " + lastMessage.id + " - " + lastMessage.data);
    }
  });
```

h2(#channel-and-presence). Channel & Presence history

Both the "@Channel@":/realtime/channels-messages and "@Presence@":/realtime/presence objects provide history. The "@Channel@":/realtime/channels-messages object provides the history of "@Message@":#message objects published on the channel, whereas the "@Presence@":/realtime/presence object provides presence event history of that channel i.e. members entering, updating or leaving the channel as "@PresenceMessage@":#presence-message objects.

h3(#persisted-history). Enabling persistent history

By default, persisted history on channels is disabled and messages are only stored by the Ably service for two minutes in memory. If persisted history is enabled for the channel, then messages will "typically be stored for 24 - 72 hours on disk":https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for.

Every message that is persisted to or retrieved from disk counts as an extra message towards your monthly quote. For example, for a channel that has persistence enabled, if a message is published, two messages will be deducted from your monthly quota. If the message is later retrieved from history, another message will be deducted from your monthly quota.

To enable history on a channel, it is necessary to add a channel rule in the settings of your "application dashboard":https://support.ably.io/solution/articles/3000030053-how-do-i-access-my-app-dashboard. See the "documentation on channel rules":https://support.ably.io/solution/articles/3000030057-what-are-channel-rules-and-how-can-i-use-them-in-my-app for further information on what they are and how to configure them.

h3(#continuous-history). Continuous history

It is possible to obtain message history that is continuous with the realtime messages received on an attached channel, in the backwards direction from the point of attachment. When a @Channel@ instance is attached, it's automatically populated by the Ably service with the serial number of the last published message on the channel. As such, using this serial number, the client library is able to make a history request to the the Ably service for all messages received since the channel was attached. Any new messages therefore are received in realtime via the attached channel, and any historical messages are accessible via the history method.

In order to benefit from this functionality, the @untilAttach@ option can be used when making history requests on attached channels. If the channel is not yet attached, this will result in an error.

```[jsall](code-editor:realtime/channel-history-until-attach)
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channnel.attach(function(err) {
    channel.history({ untilAttach: true}, function(err, resultPage) {
      var lastMessage = resultPage.items[0];
      alert('Last message before attach: ' + lastMessage.data);
    });
  });
```

```[ruby]
  realtime = Ably::Realtime.new('{{API_KEY}}')
  channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
  channnel.attach do
    channel.history(until_attach: true) do |result_page|
      last_message = result_page.items.last
      puts "Last message before attach: #{last_message.data}")
    end
  end
```

```[java]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
  channel.attach();
  channel.on(ChannelState.attached, new ChannelStateListener() {
    @Override
    public void onChannelStateChanged(ChannelState state, ErrorInfo reason) {
      Param[] options = new Param[]{ new Param("untilAttach", "true") };
      PaginatedResult<Message> resultPage = channel.history(options);
      Message lastMessage = resultPage.items[0];
      System.out.println("Last message before attach: " + lastMessage.data);
    }
  });
```

h1. API reference

inline-toc.
  History API:
    - Channel:
      - history#messages
    - Presence:
      - history#presence
    - Related types:
      - Message
      - PresenceMessage#presence-message
      - Presence action
      - PaginatedResult#paginated-result

h2(#channel-history). Channel object message history

With the REST client library, the Channel object must be created in order to retrieve history or stats for the required channel:

bc[javascript]. var Rest = new Ably.Rest(options),
    channel = Rest.channels.get('channel0');

bc[ruby]. rest = Ably::Rest.new(options)
channel = rest.channels.get('channel0')

h3. Methods

h6. history

bq(definition). channel.history(options, callback)

This call queries the REST "@/apps/<app id>/channels/<channel id>/history@":/rest-api#message-history API

h4. Parameters

- options := is an optional object containing the query parameters, as specified in the "query options below":#messages-option-params.
- callback := is a function of the form: @callback(err, result)@
where:
<ul>
<li>@err@ contains an error value on the case of an error response as defined in the "REST API":/rest-api#common documentation</li>
<li>On success, @result@ contains an array of results whose type corresponds to the result type for the request granularity as specified in "REST API":/rest-api#message-history</li>
</ul>

h4(messages-option-params). Query options

The following options are supported.

- start := Specifies the start of interval covered by the query. Defaults to the beginning of time.<br><br>
The value is either a number (milliseconds since the epoch) or a date/time string that can be parsed by JS Date (eg 2012-12-09:16:38).<br><br>
The given start time is rounded down to the start of the relevant interval depending on the granularity of the query (see below). So, for example, if the query is for stats by minute (which is the default), then the given time will be rounded down to the nearest minute.

- end := Specifies the end of interval covered by the query. Defaults to the current time.<br><br>
The value is either a number (milliseconds since the epoch) or a date/time string that can be parsed by JS Date (eg 2012-12-09:16:38).<br><br>
The interval covered by the query always includes the end time, and covers the entire interval at the requested granularity that includes the end time. (In a sense it is "rounded up", except that the end of the query interval is not a "round" time; it's the last second of the interval containing the given end time.)

- direction := Specifies the direction that results are to be returned, either backwards (ie most recent interval first) or forwards (ie oldest interval first).<br><br>
The start time and end time are always that - ie start is earlier than first, even if the direction is backwards. Therefore, when querying backwards, the first returned result will cover the end time.<br><br>
Default is backwards.

- limit := Specifies the maximum number of records to return.

- from_serial := Specifies a message serial number, requesting a history starting from that specific message. A contiguous history, to mesh precisely with the messages received in realtime from an attached channel, can be obtained by passing the appropriate serial number in this option.

- format := Specifies a format for the response, which can be:<br><br>
<ul>
<li>json</li>
<li>html</li>
<li>binary (returns records encoded as Thrift. Note that this feature is at risk for the stats API)</li>
If a format is not specified, it is inferred from an Accept or Content-Type header. The header takes precedence.<br><br>
Similarly, in the special case of json only, the request path may include the extension .json which makes a json request.

h2(#related-types). Related types

h3(#message).
  default: Message
  ruby:    Ably::Models::Message Enum
  java:    io.ably.lib.types.Message

<%= partial 'types/_message' %>

h3(#presence-message).
  default: PresenceMessage
  ruby:    Ably::Models::PresenceMessage Enum
  java:    io.ably.lib.types.PresenceMessage

<%= partial 'types/_presence_message' %>

h3(#presence-action).
  default: Presence action
  java:    io.ably.lib.types.PresenceMessage.Action
  ruby:    Ably::Models::PresenceMessage::ACTION

<%= partial 'types/_presence_action' %>

h3(#paginated-result).
  default: PaginatedResult
  ruby:    Ably::Models::PaginatedResult
  java:    io.ably.lib.types.PaginatedResult

<%= partial 'types/_paginated_result' %>
