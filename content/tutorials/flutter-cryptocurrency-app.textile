---
title: Building a Realtime Cryptocurrency App with Flutter
excerpt: Learn how to build a cryptocurrency Flutter app ussing Ably's realtime package
section: tutorials
category:
    - channels
group: sdk
index: 14
platform: browser
authors:
- author_name: Mais Alheraki
  author_bio: ""
  author_profile_url: "https://github.com/pr-Mais"
  author_image: ""
- author_name: Thomas Burkhart
  author_bio: ""
  author_profile_url: "https://github.com/escamoteur"
  author_image: ""
languages:
  - dart
level: intermediate
reading_time: 10
tags:
    - flutter
    - realtime
    - channel
    - graph
    - cryptocurrency
---

The Ably Flutter plugin is a wrapper around the Cocoa and Java client library SDKs, providing iOS and Android support for those using Flutter and Dart. It is really easy to get up and running. In this article, we'll show you how to build a realtime cryptocurrency Flutter app using this plugin. We will mainly focus on the important things you need to know to get started, along with best practices to receive and display real-time data. You can check out the "full source code on GitHub":https://github.com/ably-labs/live-cryptocurrency-streaming-flutterhttps://github.com/ably-labs/live-cryptocurrency-streaming-flutter.

h2(#realtime-in-flutter). Realtime in Flutter

Flutter is a toolkit made by Google for building cross-platform apps easily.

The tech world is increasingly moving towards event-driven systems, giving rise to a need for fast and reactive applications. The Ably Flutter plugin provides a robust and easy way to create Flutter apps with realtime capabilities.

h2(#getting-started). Getting Started

h3(#what-will-we-build). What will we build?

We’ll build a realtime cryptocurrency app with 3 screens as described below:

1. **Dashboard screen:** This will be the default home screen where we will display realtime data for cryptocurrency prices from "Ably’s Coindesk":https://www.ably.io/hub/ably-coindesk/crypto-pricing data stream on the "Ably Hub":https://www.ably.io/hub/ (more on the Hub later). Each currency will have its own line graph that shows the changes of the price over time, along with the actual updated price.

2. **Chat room screen:** This will be the chat screen which you’ll see when the chat icon is clicked. We will create a public chat room where all users who have the app can chat with others who are currently in the room.

3. **Twitter feed screen:** Clicking on the name of any given cryptocurrency on the dashboard will bring up another screen containing the twitter feed containing the latest tweets with that cryptocurrency mentioned.

h3(#pre-requisites). Pre-requisites

Before we get started, please make sure that you have Flutter correctly installed on your machine. You can do it by following the "Flutter installation guide":https://flutter.dev/docs/get-started/install.

The next step is to "sign up":https://www.ably.io/signup for a free Ably account to obtain an **Ably API key**. This is needed to make the Ably Flutter plugin work.

Ably has a set of streaming data sources that can be used free of charge in your apps and services. They are hosted on the "Ably Hub":https://www.ably.io/hub. For our application, we’ll make use of the “**Cryptocurrency pricing**”:https://www.ably.io/hub/ably-coindesk/crypto-pricing data stream. At the time of this writing, it supports the BTC, XRP, and ETH currencies and shows the corresponding prices in USD. Go ahead and click on the ‘subscribe’ button to get access to this data stream from your Ably account.

Next you need to "sign up":https://developer.twitter.com/ for a Twitter developer account to get Twitter API keys. This is needed to get the Twitter feed screen working. It’s not necessary as the application as a whole will still work even with the Twitter feed missing.

h3. Project Files Structure

bc. Lib // root folder of all dart files in a Flutter app
|_ service
|____ ably_service.dart
|____ twitter_api_service.dart
|_ view
|____ dashboard.dart
|____ twitter_feed.dart
|____ chat.dart
|_ config.dart
|_ main.dart

This is how our project’s structure will look like. The UI is going to be separated from the data source by creating services.

The most important file and the main focus of this tutorial will be @ably_service@. This is where we will write all functions and code communicating with Ably realtime.

If you cloned the project, you would notice @config_example.dart@ file, which has a few constants to hold the secret keys for Ably and Twitter APIs. Please paste your keys from the previous steps here, and rename the file to @config.dart@, you will also find notes to guide you inside the file.

**IMPORTANT:** We highly recommend not to commit this file into a public github repository.

h3. Packages and dependencies

In Flutter we can use packages to add extra functionality and make it easier to do many things without writing extra code. To use a package we just have to add the package name and version in @pubspec.yaml@, like this:

```[yaml]
dependencies:
  flutter:
    sdk: flutter
    
  ably_flutter_plugin: ^1.0.0+dev.2
  get_it: ^5.0.1
  syncfusion_flutter_charts: ^18.3.52
  http: ^0.12.2
  intl: ^0.16.1
  tweet_ui: ^2.4.2
  twitter_api: ^0.1.2
```

1. "ably_flutter_plugin":https://pub.dev/packages/ably_flutter_plugin
Ably’s Flutter package is a wrapper around existing iOS and Android packages, we will use it to connect to Ably realtime service. At the time of writing, it doesn’t yet have support for the web or desktop.
2. "get_it":https://pub.dev/packages/get_it
We’ll use the get_it package for locating the services and using them in the UI classes. It’s a popular package used to manage state in a Flutter app and help in separating Business Logic from UI, later in the tutorial we will see how to use it to connect our services with views.
3. "syncfusion_flutter_charts":https://pub.dev/packages/syncfusion_flutter_charts
Syncfusion provides a wide range of packages for Flutter, this charts package is easy to use and can be highly customized. We will use it for the charts in the dashboard page.
4. "intl":https://pub.dev/packages/intl
The most popular internationalization package for Flutter, we will use it for dates formatting.
5. "twitter_api":https://pub.dev/packages/twitter_api
Twitter has a complicated way of setting up a request, to simplify the process we will use this package which already takes care of all that complexity for us.
6. "http":https://pub.dev/packages/http
As we have a part where we will connect to Twitter’s API, this package is the easiest and most popular package to send http requests, but as you will see later, we won’t use it for this, we actually just needed it to override a simple problem with the twitter_api, it’s possible to go without it, but we will go through that part and explain why we will use it.
7. "tweet_ui":https://pub.dev/packages/tweet_ui
A ready made widget to display different types of tweets by only passing it the tweet json data.


h2(#realtime-charts). Building the Realtime Cryptocurrency Charts

Back to the "Cryptocurrency prices hub":https://www.ably.io/hub/ably-coindesk/crypto-pricing you subscribed to in a previous step, each cryptocurrency will have a _display name_ and a _code_, the code is used to connect to the specific channel of this currency on the Aply Hub, and display name is what the user will see.

We will make a const List that will have the currently available currencies on the hub, and if any new currency is added to the hub, we can add it by appending it to this list and the whole app will be updated.

```[flutter]
const List<Map> _coinTypes = [
  {
    "name": "Bitcoin",
    "code": "btc",
  },
  {
    "name": "Ethereum",
    "code": "eth",
  },
  {
    "name": "Ripple",
    "code": "xrp",
  },
];
```

h3(#cryptocurrency-data-model). Cryptocurrency Data Model

First, we need a model to hold the coin information and deliver it to the UI code, instead of sending the raw data received from Ably immediately, as this will improve readability of the code and split the service layer completely, we will use this model to map the received data.

```[flutter]
class Coin {
  final String code;
  final double price;
  final DateTime dateTime;

  Coin({
    this.code,
    this.price,
    this.dateTime,
  });
}
```

h3(#realtime-service-class). Realtime Service Class

Let’s create the main service class @AblyService@, which will have a private constructor to initialize it.

```[flutter]
Class AblyService {
  AblyService._(this._realtime);
}
```

The reason for that is we want this service to be a _Singleton_ and initialized only **once** at the app launch from a special initialization method with all the necessary connection instances.
It’s a bad idea to initialize a new instance of this service each time we need to access any method inside it, as we need every method to use the same connection information. 

To initialize our service, we will make a special @static@ method, we need it to create and return the private instance of this class for use everywhere in the app. In this method, we will also do the main configuration to establish a realtime connection to Apply.

```[flutter]
static Future<AblyService> init() async {
    /// initialize client options for your Ably account using your private API
    /// key
    final ably.ClientOptions _clientOptions =
        ably.ClientOptions.fromKey(APIKey);

    /// initialize real-time object with the client options
    final _realtime = ably.Realtime(options: _clientOptions);

    /// connect the app to Ably's Realtime services supported by this SDK
    await _realtime.connect();

    /// return the single instance of AblyService with the local _realtime
    /// instance to
    /// be set as the value of the service's _realtime property, so it can be 
    /// used in all methods.
    return AblyService._(_realtime);
}
```

Let’s take a moment to explain what we did. You can see that we are passing the local @_realtime@ instance to the constructor of the @AblyService@ class which will set the class-level @_realTime@ property, so that other methods will be able to use it. We will shortly see how it will be used to create and subscribe to channels.

Let’s now connect to the Cryptocurrency channel and read coin prices. For this we will add a function @getCointUpdates@ that will make the connection, listen to the stream of messages coming from Ably, and map each message to a Coin.

```[flutter]
List<CoinUpdates> _coinUpdates = [];

List<CoinUpdates> getCoinUpdates() {
    if (_coinUpdates.isEmpty) {
      for (int i = 0; i < _coinTypes.length; i++) {
        String coinName = _coinTypes[i]['name'];
        String coinCode = _coinTypes[i]['code'];

        _coinUpdates.add(CoinUpdates(name: coinName));

        //launch a channel for each coin type
        ably.RealtimeChannel channel = _realtime.channels
            .get('[product:ably-coindesk/crypto-pricing]$coinCode:usd');

        //subscribe to receive a Dart Stream that emits the channel messages
        final Stream<ably.Message> messageStream = channel.subscribe();

        //map each stream event to a Coin and listen to updates
        messageStream.where((event) => event.data != null).listen((message) {
          _coinUpdates[i].updateCoin(
            Coin(
              code: coinCode,
              price: double.parse('${message.data}'),
              dateTime: message.timestamp,
            ),
          );
        });
      }
    }
    return _coinUpdates;
}
```
The first thing is to iterate over the constant @_coinTypes@ list created before, and for each coin type there, we will request a channel from the Ably server which contains a Dart @Stream@. This stream will start emitting new events once we subscribe to it. We will subscribe and start listening in the UI.

h3(#notify-ui). Notifying the UI of New Data

To make it easier to consume the data we get from these Streams in the UI, we will create a new class that extends ChangeNotifier. In Flutter, the simplest way to get notified when anything changes is by using ChangeNotifier.

```[flutter]
class CoinUpdates extends ChangeNotifier {
  CoinUpdates({this.name});
  final String name;

  Coin _coin;

  Coin get coin => _coin;
  updateCoin(value) {
    this._coin = value;
    notifyListeners();
  }
}
```

Any UI widget that registers a listener for this object will get a notification whenever it has to rebuild with new data.

The update will happen when calling the @updateCoin()@ method, which will assign the new coin data to @_coin@, then call @notifyListeners()@.

We chose to transform Stream events into **ChangeNotifier** updates because they are much easier to use in the UI as they always have a valid value and don’t care if they are listened to multiple times.

h3. Subscribe to Ably Channels

Let’s break down the previous function and explain more how we are subscribing to the cryptocurrency channel in 4 steps:

1. Get the list of realtime channels for your account, then get a specific one by its name

```[flutter]
ably.RealtimeChannel channel = _realtime.channels.get('[product:ably-coindesk/crypto-pricing]$coinCode:usd');
```

In a real App it’s probably a good idea to check if we got the channel that we requested.

2. Subscribe to the chosen channel

```[flutter]
final Stream<ably.Message> messageStream = channel.subscribe();
```

3. The returned type from @subscribe()@ is a @Stream<Message>@, which feels a bit odd because we just subscribed to something. In reality the @subscribe@ tells Ably to start transmitting data.

4. So we register a listener for this message Stream, and use `where` to filter null values.

```[flutter]
messageStream.where((event) => event.data != null).listen((message) {});
```

As we never stop listening to the channels in this app we can ignore the @StreamSubscription@ that is returned from @listen()@.

Inside the listener, whenever a new message arrives, we call `updateCoin()` and pass it a new Coin mapped from the Message data.

The return type of this function is a @List<CoinUpdates>@ which has the same length as @_coinTypes@ and with a @CoinUpdates@ object for every currency defined in @coinTypes@. 

To be safe in case that this function is called more than once we wrap the @for@ loop in an @if@ that checks if we already have made our channel subscription.

Now we have finished setting up all we need for the service, it’s time to see how we will use it to show the prices graphs. 

To be able to access our services easily we use the service locator package @get_it@. You could also use @package/provider@ or any other solution that you are comfortable with.

The following diagram visualizes how the data will flow from Ably to our App’s UI.

h3(#register-get-it). Registering Services with get_it

First step is to register the service using get_it:

```[flutter]
GetIt getIt = GetIt.instance;

void main() {
  getIt.registerSingletonAsync<AblyService>(() => AblyService.init());
  runApp(MyApp());
}
```

We will do that asynchronously in the main method, as we want this service to be available as soon as the app is launched.

For more information on how asynchronous registration with @get_it@ works see https://github.com/fluttercommunity/get_it#asynchronous-singletons.

As this is an asynchronous registration, it won’t be available to our UI immediately, so we will wait for it at some place before using it. For this we will use a @FutureBuilder@ which will show a loading spinner until get_it reports that all services are ready.

```[flutter]
FutureBuilder(
     future: getIt.allReady(),
     builder: (context, snapshot) {
       if (!snapshot.hasData)
         return Center(child: CircularProgressIndicator());
       else
         return GraphsList();
     },
   ),
```

h3(#listening-to-prices). Listening to Cryptocurrency Prices

Now that we are sure the service is definitely going to be ready at the time we use it, we will make a new Stateful Widget so that we can register a listener to listen to cryptocurrency prices in its @initState()@.

```[flutter]
List<CoinUpdates> prices = [];

@override
void initState() {
    prices = getIt<AblyService>().getCoinUpdates();
    super.initState();
}
```

At first, the prices will not be ready yet because the app is still connecting to Ably, so now we need to have the service telling us what the connection status is. 

For this we will make a new property in the AblyService called @connection@ of type Stream that will report all connection status changes.

```[flutter]
Stream<ably.ConnectionStateChange> get connection =>  _realtime.connection.on();
```

Since it’s a Stream, we will use a @StreamBuilder@ to read the connection status, and then decide what to display in different cases.

```[flutter]
StreamBuilder<ably.ConnectionStateChange>(
    // as we are behind the FutureBuilder we can safely access AblyService 
    stream: getIt<AblyService>().connection,
    builder: (context, snapshot) {
      if (!snapshot.hasData) {
        return CircularProgressIndicator();
      } else if (snapshot.data.event == ably.ConnectionEvent.connected) {
       // return the list of graphs, 
         SingleChildScrollView(
            //see below
         );
      } else if (snapshot.data.event == ably.ConnectionEvent.failed) {
        return Center(child: Text("No connection."));
      } else {
    // in a real app we would also add handling of possible errors
        return CircularProgressIndicator();
      }
    },
),
```

Now that all cases are handled, let’s display the list of charts if the connection was successful.

h3(#display-charts). Displaying Charts with Real Data

```[flutter]
SingleChildScrollView(
	child: Column(
		children: [
			for (CoinUpdates update in prices)
   CoinGraphItem(coinUpdates: update),
		 ],
	),
),
```
Instead of using a @ListView.builder@, it’s just a @Column@, with a @for-collection@, we found this to be more convenient in this case, since the @ListView@ by default will dispose the states of any child that isn’t visible anymore. That's good behaviour in case a list is very long, but since we know already the number of graphs is limited, and we don’t want them to dispose and rebuild each time the user scrolls up or down, a @Column@ is totally fine.

Each @CoinGraphItem@ widget will require @CoinUpdates@, and since it’s extending ChangeNotifier, it will register a listener for prices updates, and push each new price coming into a @Queue@ because if we would use a List, after some time the size of the list will get  huge, and require too much resources, and we don’t really have to show all the history of prices, just the latest 100 would be enough. With a Queue it’s easy to remove the first item if the length exceeds a certain length.

```[flutter]
Queue<Coin> queue = Queue();
String coinName = '';

VoidCallback _listener;

@override
void initState() {
    widget.coinUpdates.addListener(
      _listener = () {
        setState(() {
          queue.add(widget.coinUpdates.coin);
        });

        if (queue.length > 100) {
          queue.removeFirst();
        }
      },
    );

    if (coinName.isEmpty) coinName = widget.coinUpdates.name;

    super.initState();
}
```

To be safe, it’s always a good practice to cancel any listeners at disposal.

```[flutter]
@override
void dispose() {
    widget.coinUpdates.removeListener(_listener);
    super.dispose();
}
```

All set up and ready! We just need the queue to be turned into a list for the graph to start rendering the data with the price as Y axis, and time as X axis.

Here we will use the Syncfusion charts package to render the charts, but any other charts library should work well.

```[flutter]
SfCartesianChart(
  enableAxisAnimation: true,
  primaryXAxis: DateTimeAxis(
    dateFormat: intl.DateFormat.Hms(),
    intervalType: DateTimeIntervalType.minutes,
    desiredIntervals: 10,
    axisLine: AxisLine(width: 2, color: Colors.white),
    majorTickLines: MajorTickLines(color: Colors.transparent),
  ),
  primaryYAxis: NumericAxis(
    desiredIntervals: 6,
    decimalPlaces: 4,
    axisLine: AxisLine(width: 2, color: Colors.white),
    majorTickLines: MajorTickLines(color: Colors.transparent),
  ),
  plotAreaBorderColor: Colors.white.withOpacity(0.2),
  plotAreaBorderWidth: 0.2,
  series: <LineSeries<Coin, DateTime>>[
    LineSeries<Coin, DateTime>(
      animationDuration: 0.0,
      width: 2,
      color: Theme.of(context).primaryColor,
      dataSource: queue.toList(),
      xValueMapper: (Coin coin, _) => coin.dateTime,
      yValueMapper: (Coin coin, _) => coin.price,
    )
  ],
)
```

With that we finished building the first page, fully functional with realtime updates from Ably Cryptocurrency Hub.

h2(#chat-room). Building the Flutter Chat Room

In the previous section, we subscribed to a channel as consumers, so we don’t own the other side of the channel and we can’t add data to it. In this section, we will take a look at how we create channels programmatically, subscribe to them and publish messages. 

Building the chat room is fairly simple, and with Ably realtime capability, it works like a charm with little code.

Back to @AblySevice@, we will add two methods, one to listen to the latest messages as long as a user is inside the chat room, and the other is to send new messages.

```[flutter]
ChatUpdates getChatUpdates() {
  ChatUpdates _chatUpdates = ChatUpdates();

  _chatChannel = _realtime.channels.get('public-chat');

  var messageStream = _chatChannel.subscribe();

  messageStream.listen((message) {
    _chatUpdates.updateChat(
      ChatMessage(
        content: message.data,
        dateTime: message.timestamp,
        isWriter: message.name == "${_realtime.clientId}",
      ),
    );
  });

  return _chatUpdates;
}
```

Channel names can be chosen almost freely. All names are always only valid for one specific app, so channels of different apps can have the same name (if you want to send messages from one app to the other you can do this by using an API Streamer). For the chat we will use @public-chat@. The name of the channel has to be the same when sending and receiving messages. If that’s not the case this would mean we are listening to a different channel than the one we publish to, so no messages will be received.

If the channel doesn’t exist at the time this function is called, it will be created as a new one automatically.

Just like we did previously with prices, we will create @ChatUpdates@ as a @ChangeNotifier@ holding the most recently published message and push it to a queue in the UI. By calling @getChatUpdates()@ on the same instance of @AblyService@ registered previously with get_it, listening on the chat channel will be started and each new message arrives will be delivered to the listeners.

For sending messages we will add @sendMessage()@ to the service.

```[flutter]
Future sendMessage(String content) async {
  _realtime.channels.get('public-chat');

  await _chatChannel.publish(data: content, name: "${_realtime.clientId}");
}
```

To publish messages, we will call @publish@ with the name of the channel, and it will send the messages to it. The @name@ parameter is optional, it can be used to differentiate different types of messages that are sent over the same channel. We defined it to be the current client ID of the connected device, so we can differentiate the messages sent by the current user from other messages of other users on the chat channel.

To not add unnecessary code for this demo app we don’t store the client ID which means it will change every time you start the app.

With this our chat infrastructure in the service is done. So lets move to the chat view. Once we open it, we need it to initialize a listener, just like we did on the main page @DashboardView@.

In @chat.dart@ we will initialize the channel and set up our listener:

```[flutter]
Queue<ChatMessage> messages = Queue();
ChatUpdates chatUpdates;
VoidCallback _listener;

@override
void initState() {
  super.initState();
  
  chatUpdates = getIt<AblyService>().getChatUpdates();

  chatUpdates.addListener(
    _listener = () {
      if (chatUpdates.message != null)
        setState(() {
          messages.addFirst(chatUpdates.message);
        });
      if (messages.length > 100) {
        messages.removeFirst();
      }
    },
  );
}
```

As we have the client ID sent with each message, we know if a message is coming from the current user or from other users on the same channel so we can change the look of the message bubble accordingly.

To display the chat bubbles we will use a @ListView.builder()@ widget. As messages should appear in the reverse order, in the messages queue, the first item is always the most recent message, so we will display the item in reverse order such that the first message appears at the bottom always.

```[flutter]
Flexible(
  child: ListView.builder(
    reverse: true,
    itemCount: messages.length,
    itemBuilder: (context, index) {
      return ChatMessageBubble(
        message: messages.toList()[index],
        isWriter: messages.toList()[index].isWriter,
      );
    },
  ),
),
```

Each list item is a message, so we will create a custom widget to render a message bubble, and it will have 2 different looks, one when the message is from the current user, and another for messages from other users.

```[flutter]
class ChatMessageBubble extends StatelessWidget {
  const ChatMessageBubble({
    Key key,
    this.message,
    this.isWriter = false,
  }) : super(key: key);
  final ChatMessage message;
  final bool isWriter;

  final double radius = 15;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: EdgeInsets.all(15),
      child: Column(
        crossAxisAlignment:
            isWriter ? CrossAxisAlignment.end : CrossAxisAlignment.start,
        children: [
          Container(
            padding: EdgeInsets.all(10),
            alignment: Alignment.centerLeft,
            decoration: BoxDecoration(
              color: isWriter
                  ? Theme.of(context).primaryColor.withOpacity(0.5)
                  : Colors.white12,
              borderRadius: BorderRadius.only(
                bottomLeft: Radius.circular(isWriter ? radius : 0),
                bottomRight: Radius.circular(isWriter ? 0 : radius),
                topLeft: Radius.circular(radius),
                topRight: Radius.circular(radius),
              ),
            ),
            width: MediaQuery.of(context).size.width * 0.6,
            constraints: BoxConstraints(minHeight: 50),
            child: Text(message.content),
          ),
          SizedBox(height: 5),
          Align(
            alignment: isWriter ? Alignment.bottomRight : Alignment.bottomLeft,
            child: Text(
              intl.DateFormat.Hm().format(message.dateTime),
              style: TextStyle(color: Colors.white24),
              textAlign: TextAlign.left,
            ),
          )
        ],
      ),
    );
  }
}
```

h2(#coin-twitter). Viewing Recent Tweets for Each Coin

To display Tweets that have a hashtag of the coin name, we will create a second service to connect to the Twitter API.T It’s a good practice to separate different data sources into separate service classes. 

Before starting, it's worth noting that this tutorial is using **Twitter API 1.0**.

If you want to try this part in your own app you have to register for a twitter developer account to get your own private API keys, because Twitter doesn't allow us to share ours with you. When you get your Twitter development account, generate your keys in the Twitter developer console and add them to @config.dart@.

To query the Twitter API manually with a HTTP request is a bit complex because it requires a lot of calculations to get the signature for each request. To make our life a bit easier we will use the "twitter_api":https://pub.dev/packages/twitter_api package, and "tweet_ui":https://pub.dev/packages/tweet_ui package to display tweets.

The @twitter_api@ package that deals with all the signature and authorization details only works for 1.0 API of Twitter. Note that you still can implement the API access using Dart only, but the focus of this tutorial isn’t Twitter’s API, so we went with this package.

Before we can use the @twitterApi@ we will have to initialize it with all the required keys:

```[flutter]
TwitterAPIService({this.queryTag}) {
  _twitterApi = twitterApi(
    consumerKey: OAuthConsumerKey,
    consumerSecret: OAuthConsumerSecret,
    token: OAuthToken,
    tokenSecret: OAuthTokenSecret,
  );
}
```

To get recent tweets we will use the standard Twitter search endpoint:

```[flutter]
static const String path = "search/tweets.json";
```

Everything ready now, a twitterApi instance is initialized with the keys, it’s time to request tweets based on the hashtag passed through the constructor:

```[flutter]
Future<List> getTweetsQuery() async {
  try {
    // Make the request to twitter
    Response response = await _twitterApi.getTwitterRequest(
      // Http Method
      "GET",
      // Endpoint you are trying to reach
      path,
      // The options for the request
      options: {
        "q": queryTag,
        "count": "50",
      },
    );

    final decodedResponse = json.decode(response.body);

    return decodedResponse['statuses'] as List;
  } catch (error) {
    rethrow;
  }
}
```

This time it won’t be a Stream, but a Future. The package uses @http@ under the hood, so the returned type from the request is an http @Response@, and it needs to be decoded. Here is why we explicitly imported http, to give a type to the response, we could proceed without it with just @final response@, but it’s a good and really necessary practice in Flutter and Dart to always be explicit with types.

final decodedResponse = json.decode(response.body);

The response body is a Map, all the tweets data are inside a list, and this list has a key `statuses`, that’s why the returned value is decodedResponse['statuses'].

On the UI side we will use the @tweet_ui@ package to display the Tweets in their familiar design.

You don’t have to use this package and you can always implement your own widget for the tweets if you like.

We could have registered the Twitter service in get_it too but as we always create the Tweets page freshly and there is no data that has to be persisted we decided to always create a new instance when the @TwitterfeedView@ is pushed as a new page.

So when the Tweet page is pushed, we will first initialize a service instance in @getTweets()@ using the hashtag that was passed from the dashboard. Then, we will call @getTweetsQuery@. As it returns a Future, we need to @await@ the result. Once the result is ready, we update the local state of the widget using @setState@ which will call the build method to switch from displaying a loading indication to the actual list of tweets.

We can’t do this directly inside @initState@ because this API is asynchronous, and @initState@ can’t be defined as an async function. So we will use a separate async method @getTweets()@ that we call from @initState@ without awaiting it. We can do this safely as we already have ensured that the page will render correctly without any received data.

```[flutter]
Future getTweets() async {
  final twitterService = TwitterAPIService(queryTag: widget.hashtag);

  try {
    final List response = await twitterService.getTweetsQuery();

    setState(() {
      tweetsJson = response;
    });
  } catch (error) {
    setState(() {
      errorMessage = 'Error retrieving tweets, please try again later.';
    });
  }
}
```

If any exception is rethrown by the service, which could happen if you don’t use valid keys or if there is a network problem, it will display a nice error message without the app pausing on the exception.

h2(#conclusion). Conclusion
If you would like to read more on Ably’s realtime services, "click to find the official documentation":https://www.ably.io/documentation/realtime/channels/ which has example code on each point for Flutter.

The full source code is "available here on GitHub":https://github.com/ably-labs/live-cryptocurrency-streaming-flutter.

h2(#resources). Resources

