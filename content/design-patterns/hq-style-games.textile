---
title: HQ style games
section: design-patterns
index: 31
languages:
  - none
---

HQ style apps have suddenly become popular. Here's how you can build your own HQ style applications.

h2(#what). What are HQ style apps?

In the recent past, a live quiz game called "HQ Trivia":https://en.wikipedia.org/wiki/HQ_Trivia has become quite popular. It's a TV game show, playable via their smartphone app. The idea is that a live TV show airs at a particular time while participants can play the live game for free using their smartphones. Participants have 10 seconds to try their luck, on each question asked.

In such a scenario, speed and latency play huge roles. The app rewards winners with great amounts of money, hence, the tech behind the app cannot afford to go wrong. It gives quite a  unique experience to the users. This design pattern aims at explaining how you can build apps like this yourself, using Ably's realtime platform.

h2(#how). Implementation based on message volumes <TODO-change-title>

Ably offers various tools to implement different realtime messaging functionality. However, some of these are capable of scaling based on the expected message volumes and others are ideal for lower volumes. Let's understand which tool is best suited for what message volumes.

<a href="/images/diagrams/dp-hq-style.png" target="_blank">
  <img src="/images/diagrams/dp-hq-style.png" style="width: 100%" alt="HQ style apps design pattern using Ably">
</a>

h3(#lowvolumes). For regular volumes <TODO-mention-range>

The implementation details are essentially captured in the figure above. Explanation is below:

* People join the "clustered" broadcast, presence and publish channel with names such as 
** "cluster­-x-­broadcast"
** "cluster­-x-presence"
** "cluster­-x-publish"

This is something you can control from your end when a client connects. If the cluster sizes turn out to be slightly larger or slightly smaller that's not really an issue, so long as the clusters are kept at their target sizes.

* Everyone will have presence permissions on the presence channel, but not subscribe permission.  This means you have the ability to query the presence on a channel, or subscribe to presence events from your servers, but everyone else won't be able to inspect / subscribe to this channel. This avoids another classic n­-squared problem i.e. 10k people entering and subscribing to 10k ‘presence-enter’ events would result in 100m messages. However, 10k people entering, generating 10k presence events only for your servers results in just 20k messages. 

h3(#highvolumes). For high volumes <TODO-mention-range>

* You can subscribe to this data via the Reactor. 

* All the people subscribe to the broadcast channels, but they only have subscribe permission, no publish permissions. Any data to be sent to all the users from your servers will be sent on this channel. 

* Everyone has publish rights to the publish channel, but no subscribe rights. This publish channel can be set up to use the Reactor so you get a buffer/ shock absorber to cope with a high volume of incoming messages. 

h2(#order). Latencies are sorted but what about the order of messages?

* Ably ensures that messages are delivered to persistently connected subscribers on a channel in the order they were published on that channel by any other client when using one of our Realtime libraries. Read more about it in one of our "support articles":https://support.ably.io/support/solutions/articles/3000044641-reliable-message-ordering-for-connected-clients.

h2(#caveats). Caveats

* Every event from a user, such as entering, publishing a chat message, playing the game in some way, does not necessarily result in a message to all.  You would in your server perform aggregation, filtering, and rate limiting.

* This ensures that your server has full control over data rate (for instance <5hz) as well as volume of messages and you can elect to filter as you see fit.

h2(#pros). Pros

* You have a reliable way to consume data from clients with a shock absorber (the queue), as well as being able to simplify how you process data using workers. 

* You can ensure you have a constant amount of data published and received regardless of cluster size or activity. Clients won't become "overloaded" with too much data, potentially that you don't have control over.

h2(#cons). Cons
<TODO-add-cons>