---
title: Reactor Functions
section: general
index: 22
---

Reactor Functions allow your server-less functions to be invoked following channel lifecycle events (such as channel creation), presence events (such as members entering or leaving) or messages being published. Reactor Functions are offered as part of our "Ably Reactor Event service":https://www.ably.io/reactor, a service available to all customers of the Ably platform.

p(tip). Reactor Functions are "rate limited":#transport and designed for low to medium volumes of updates. If you expect a high volume of events and messages (upwards of 20 per second), then you should consider using our "message queues":/general/queues or "firehose":/general/firehose instead as they are designed to scale without limits.

Generally, customers who want to receive events as they happen, use our "message queues":/general/queues or "firehose":/general/firehose, or alternatively our "realtime client libraries":/realtime and subscribe to events and messages published. However, some customers prefer a server-less architecture and want to have their code invoked when a user publishes a message, attaches to a channel, or enters the presence set on a channel. For example, a developer may want to send a welcome message to someone when they first enter a chat channel. A Reactor Function can be used to achieve this.

Reactor Functions are are designed to trigger server-less functions on common platforms such as Amazon and Google.  If you are looking to trigger the execution of code on your own servers over HTTP when a message is published or event occurs, see our "Reactor WebHooks":/general/webhooks.

h2. Message Format

The format of messages sent can be defined in your "account dashboard":https://support.ably.io/solution/articles/3000048664-how-do-i-access-my-account-dashboard. You can have the message sent as a JSON message, or as a "MessagePack":https://msgpack.org.

* JSON (JavaScript Object Notation): An efficient data-interchange format which is fairly standard and provides simple text based encoding.
* MsgPack: An efficient binary serialization format that is similar to JSON, but faster and smaller.


h2. Envelopes

If you're using JSON you can have messages contained within an envelope. This can be useful for clients which are unable to access response headers or status codes.


h2. Payload types

Ably currently supports two types of data that can be delivered via our Functions:

* "Messages":#messages - messages trigger function calls as soon as they are published on a channel
* "Presence events":#presence - when clients enter, update their data, or leave channels, the presence event triggers a function call

You can "configure Functions":#configure from the Reactor tab in your "account dashboard":https://support.ably.io/solution/articles/3000048664-how-do-i-access-my-account-dashboard on a per app basis which can apply to one or more channels in that app. Reactor Functions can be filtered by channel naming using a regular expression.



h2(#messages). Messages

If you are unfamiliar with how channels work in Ably, we recommend you first review the "realtime channel documentation":/realtime/channels-messages#channels.

When a message is published on a channel, a Reactor Function message event is triggered, which in turn will send a message to your server-less function.

Every request will contain your message within the @body@ part of the request. The contents of the @body@ depends on the format of your messages, and whether you've used an envelope or not.

* No Envelope - Without an envelope, the contents of @body@ will simply be the contents message that was sent on the Ably Channel. 

* Envelope - If you use an envelope, the @body@ will contain a bunch of extra attributes, which are the following:


- source := the source of the request, namely "@channel.message"
- appId := the ID of your application with Ably
- channel := name of the channel the Ably Message was published on
- site := an internal site identifier indicating the data center from which the message was published
- ruleId := an ID for the rule which has created this request
- messages := an @Array@ of messages with fields for each message described below

Each member of @messages@ has the following fields:

- id := unique ID assigned by Ably to this message
- name := a string representing the event name for the published message, see the "publish method":/rest/
- connectionId := the public unique identifier for the publisher's connection. Find out more about "@connectionId@":/realtime/connection#id
- timestamp := the time in milliseconds since the epoch when this message was received by Ably
- data := the data payload for the published message. Find out more about "message data":/rest/channels-messages#message

h4. Decoding messages

Each member of @messages@ is a 'raw' message. Messages sent "over the realtime service":/realtime/channels-messages are automatically decoded into "@Messages@":/realtime/types#message object by the Ably client library. With Reactor Functions you need to to do this explicitly, using "@Message.fromEncodedArray@":/realtime/channels-messages#message-from-encoded-array on the @messages@ array, or "@Message.fromEncoded@":/realtime/channels-messages#message-from-encoded on an individual member of that array. This will transform them into an array of "@Messages@":/realtime/types#message (or in the case of @fromEncoded@, an individual "@Message@":/realtime/types#message). This has several advantages, e.g.:

* It will fully decode any @data@ (using the @encoding@) back into the same datatype that it was sent in (or an equivalent in each client library's language)
* If you are using "encryption":/realtime/encryption, you can pass your encryption key to the method and it will decrypt the @data@ for you

We recommend you do this for all messages you receive through Reactor Functions. For example (using ably-js):

```[javascript]
  const messages = Ably.Realtime.Message.fromEncodedArray(request.messages);
  context.log(messages.toString());
```


h4. Example @channel.message@ JSON payload

```[json]
{
   "items":[
      {
         "source":"channel.message",
         "appId":"ABCDef"
         "channel":"your_channel",
         "site":"eu-west-2-A",
         "ruleId":"rUlEID",
         "messages":[
            {
               "id":"9qaOH1C4tO:2:0",
               "name":"foo",
               "connectionId":"9qaOH1C4tO",
               "timestamp":1479301189856,
               "data":"bar"
            }
         ]
      }
   ]
}
```

Please note that if you are planning to receive messages via Ably Functions, it is theoretically very easy to exceed the "transport rate limits":#transport we impose on Reactor Function to prevent DoS attacks against your own servers. We recommend you consider "message queues":/general/queues instead as they are far more scalable.


h2(#presence). Presence events

If you are unfamiliar with how presence works in Ably and what events are supported, we recommend you first review the "realtime presence documentation":/realtime/presence.

When a member enters, updates, or leaves a channel, a presence @message@ event is triggered.

Every Reactor Function request instigated by a presence event will contain details of the presence event within the @body@ attribute, stored as an array.

The contents of the @body@ depends on the format of your messages, and whether you've used an envelope or not.

* No Envelope - Without an envelope, the contents of @body@ will simply be the contents of the message that was sent on the Ably Channel. 

* Envelope - If you use an envelope, the @body@ will contain a bunch of extra attributes, which are the following:
- source := the source of the request, namely "@channel.message"
- appId := the ID of your application with Ably
- channel := name of the channel the Ably Message was published on
- site := an internal site identifier indicating the data center from which the message was published
- ruleId := an ID for the rule which has created this request
- presence := an @Array@ of presence events

Each member of @presence@ has the following fields:

- id := unique ID assigned by Ably to this message
- clientId := the client identifier for the member. Find out more about "identified clients":https://support.ably.io/solution/articles/3000038608-authenticated-and-identified-clients
- connectionId := the public unique identifier for the publisher's connection. Find out more about "@connectionId@":/realtime/connection#id
- timestamp := the time in milliseconds since the epoch when this message was received by Ably
- action := the presence action, as an integer defined by the "PresenceMessage Action enum":https://www.ably.io/documentation/realtime/types#presence-action.

h4. Decoding presence events

Each member of @presence@ is a 'raw' presence event. Presence messages sent "over the realtime service":/realtime/channels-messages are automatically decoded into "@PresenceMessages@":/realtime/types#presence-message object by the Ably client library. With Reactor Function you need to to do this explicitly, using "@PresenceMessage.fromEncodedArray@":/realtime/presence#presence-from-encoded-array on the @presence@ array, or "@PresenceMessage.fromEncoded@":/realtime/presence#presence-from-encoded on an individual member of that array. This will transform them into an array of "@PresenceMessages@":/realtime/types#presence-message (or in the case of @fromEncoded@, an individual "@PresenceMessage@":/realtime/types#presence-message). This has several advantages, e.g.:

* It will decode the (numerical) action into a "@Presence action@":/realtime/presence#presence-action string (such as "@enter@", "@update@", or "@leave@")
* It will fully decode any @data@ (using the @encoding@) back into the same datatype that it was sent in (or an equivalent in each client library's language)
* If you are using "encryption":/realtime/encryption, you can pass your encryption key to the method and it will decrypt the @data@ for you

We recommend you do this for all presence messages you receive through Reactor Functions. For example (using ably-js):

```[javascript]
const presMsgs = Ably.Realtime.PresenceMessage.fromEncodedArray(presenceMsg.data.presence);
console.log(presMsgs.toString());
```


h4. Example @channel.presence@ @enter@ JSON payload

```[json]
{
   "items":[
      {
         "source":"channel.message",
         "appId":"ABCDef"
         "channel":"your_channel",
         "site":"eu-west-2-A",
         "ruleId":"rUlEID",
         "presence":[
            {
               "id":"9qaOH1C4tO:2:0",
               "clientId":"foo",
               "connectionId":"9qaOH1C4tO",
               "timestamp":1479301189856,
               "action":"2"
            }
         ]
      }
   ]
}
```




h2. Server-less platform support

We can support the following server-less platforms:

* Amazon Lambda
* Google Cloud Function
* Azure Functions

We also offer Custom Endpoints to our "Enterprise":https://www.ably.io/pricing/enterprise customers.

h2(#troubleshooting). Troubleshooting Functions

If you are finding it hard to debug a problem with Reactor Functions, we recommend you review "our recommendations for debugging Functions":https://support.ably.io/solution/articles/3000074193-how-can-i-debug-reactor-function. If this does not help, please "get in touch with us":https://www.ably.io/contact so that we can help you with your problem.


h2. Next steps

* "Follow one of our Reactor Function step-by-step tutorials":/tutorials